<!DOCTYPE html> 
 <html> 
 <head> 
     <meta charset="UTF-8"> 
     <title>Leaflet | Advanced DXF Viewer</title> 
      
     <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" /> 
      
     <!-- Supabase JavaScript 클라이언트 --> 
     <script src="https://unpkg.com/@supabase/supabase-js@2"></script> 
      
     <!-- Supabase 연결 설정 --> 
     <script> 
         // Supabase 클라이언트 초기화 
         const supabaseUrl = 'https://txlkfywysdnoigcwbags.supabase.co'; 
         const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR4bGtmeXd5c2Rub2lnY3diYWdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MTU4NDEsImV4cCI6MjA2OTE5MTg0MX0.svkW2EFuqUTfomf8_FDRhdghfCC5_NbmF1zEXhI3TD0'; 
          
         // supabase 객체가 로드될 때까지 대기 
         window.addEventListener('load', function() { 
             if (typeof supabase !== 'undefined') { 
                 window.supabaseClient = supabase.createClient(supabaseUrl, supabaseKey); 
                 console.log('🚀 Supabase 클라이언트 초기화 완료'); 
                  
                 // 연결 테스트 
                 window.supabaseClient.table('blasting_locations').select('count').execute() 
                     .then(response => { 
                         console.log('✅ Supabase 연결 테스트 성공:', response); 
                     }) 
                     .catch(error => { 
                         console.error('❌ Supabase 연결 테스트 실패:', error); 
                     }); 
             } else { 
                 console.error('❌ Supabase 라이브러리가 로드되지 않음'); 
             } 
         }); 
     </script> 
      
     <style> 
         html, body, #map { margin: 0; height: 100%; width: 100%; overflow: hidden; } 
          
         /* 좌측 메인 컨트롤 패널 */ 
         .main-control-panel { 
             position: absolute; 
             top: 0; 
             left: 0; 
             width: 320px; 
             height: 100%; 
             background: rgba(255, 255, 255, 0.98); 
             border-right: 2px solid #e0e0e0; 
             z-index: 1000; 
             font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
             box-shadow: 2px 0 10px rgba(0,0,0,0.1); 
             overflow-y: auto; 
         } 
          
         .main-control-panel h3 { 
             margin: 0; 
             padding: 20px 20px 15px 20px; 
             color: #333; 
             font-size: 18px; 
             border-bottom: 2px solid #007bff; 
             background: #f8f9fa; 
         } 
          
         .control-section { 
             padding: 15px 20px; 
             border-bottom: 1px solid #eee; 
         } 
          
         .control-section h4 { 
             margin: 0 0 12px 0; 
             color: #007bff; 
             font-size: 14px; 
             font-weight: 600; 
             display: flex; 
             align-items: center; 
         } 
          
         .control-section h4 i { 
             margin-right: 8px; 
             font-size: 16px; 
         } 
          
         .file-upload-section { 
             background: #f8f9fa; 
             border-radius: 8px; 
             padding: 15px; 
             margin: 10px 0; 
         } 
          
         .file-upload-section input[type="file"] { 
             width: 100%; 
             padding: 8px; 
             border: 2px dashed #007bff; 
             border-radius: 6px; 
             background: white; 
             font-size: 12px; 
             cursor: pointer; 
         } 
          
         .file-upload-section input[type="file"]:hover { 
             border-color: #0056b3; 
             background: #f0f8ff; 
         } 
          
         #status { 
             margin-top: 10px; 
             padding: 8px 12px; 
             background: #e7f3ff; 
             border-left: 4px solid #007bff; 
             border-radius: 4px; 
             font-size: 12px; 
             color: #0056b3; 
         } 
          
         #layer-control { 
             max-height: 300px; 
             overflow-y: auto; 
             background: white; 
             border: 1px solid #e0e0e0; 
             border-radius: 6px; 
             padding: 10px; 
         } 
          
         .layer-item { 
             display: flex; 
             align-items: center; 
             padding: 8px 0; 
             border-bottom: 1px solid #f0f0f0; 
         } 
          
         .layer-item:last-child { 
             border-bottom: none; 
         } 
          
         .layer-item input[type="checkbox"] { 
             margin-right: 10px; 
             transform: scale(1.2); 
         } 
          
         .layer-item label { 
             flex: 1; 
             font-size: 12px; 
             color: #333; 
             cursor: pointer; 
         } 
          
         .layer-opacity { 
             width: 60px; 
             height: 20px; 
             margin-left: 10px; 
         } 
          
         /* 도구 패널 스타일 */ 
         .tools-panel { 
             position: absolute; 
             top: 20px; 
             right: 20px; 
             background: rgba(255, 255, 255, 0.98); 
             padding: 20px; 
             border-radius: 12px; 
             border: 2px solid #e0e0e0; 
             z-index: 1000; 
             font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
             box-shadow: 0 6px 20px rgba(0,0,0,0.15); 
             min-width: 180px; 
         } 
          
         .tools-panel h4 { 
             margin: 0 0 15px 0; 
             color: #333; 
             font-size: 14px; 
             text-align: center; 
             font-weight: 600; 
             border-bottom: 2px solid #007bff; 
             padding-bottom: 8px; 
         } 
          
         .tool-button { 
             display: block; 
             width: 100%; 
             padding: 12px 15px; 
             margin: 8px 0; 
             background: white; 
             border: 2px solid #e0e0e0; 
             border-radius: 8px; 
             cursor: pointer; 
             transition: all 0.3s ease; 
             text-align: center; 
             font-size: 13px; 
             font-weight: 500; 
             color: #555; 
         } 
          
         .tool-button:hover { 
             background: #007bff; 
             color: white; 
             border-color: #007bff; 
             transform: translateY(-2px); 
             box-shadow: 0 4px 12px rgba(0,123,255,0.3); 
         } 
          
         .tool-button.active { 
             background: #007bff; 
             color: white; 
             border-color: #007bff; 
             box-shadow: 0 4px 12px rgba(0,123,255,0.3); 
         } 
          
         .tool-button i { 
             display: block; 
             font-size: 24px; 
             margin-bottom: 5px; 
         } 
          
         /* 모달 스타일 */ 
         .modal { 
             display: none; 
             position: fixed; 
             z-index: 2000; 
             left: 0; 
             top: 0; 
             width: 100%; 
             height: 100%; 
             background-color: rgba(0,0,0,0.5); 
         } 
          
         .modal-content { 
             background-color: white; 
             margin: 15% auto; 
             padding: 20px; 
             border-radius: 8px; 
             width: 80%; 
             max-width: 400px; 
             box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
         } 
          
         .modal-header { 
             display: flex; 
             justify-content: space-between; 
             align-items: center; 
             margin-bottom: 20px; 
         } 
          
         .modal-title { 
             font-size: 18px; 
             font-weight: bold; 
             color: #007bff; 
         } 
          
         .close { 
             color: #aaa; 
             font-size: 28px; 
             font-weight: bold; 
             cursor: pointer; 
         } 
          
         .close:hover { 
             color: #000; 
         } 
          
         .form-group { 
             margin-bottom: 15px; 
         } 
          
         .form-group label { 
             display: block; 
             margin-bottom: 5px; 
             font-weight: bold; 
             color: #333; 
         } 
          
         .form-group input, .form-group textarea { 
             width: 100%; 
             padding: 8px; 
             border: 1px solid #ddd; 
             border-radius: 4px; 
             font-size: 14px; 
         } 
          
         .form-group textarea { 
             height: 80px; 
             resize: vertical; 
         } 
          
         .btn { 
             background: #007bff; 
             color: white; 
             padding: 10px 20px; 
             border: none; 
             border-radius: 4px; 
             cursor: pointer; 
             font-size: 14px; 
             margin-right: 10px; 
             transition: all 0.3s ease; 
             font-weight: 500; 
         } 
          
         .btn:hover { 
             background: #0056b3; 
             transform: translateY(-1px); 
             box-shadow: 0 4px 8px rgba(0,123,255,0.3); 
         } 
          
         .btn:active { 
             transform: translateY(0); 
             box-shadow: 0 2px 4px rgba(0,123,255,0.3); 
         } 
          
         .btn-secondary { 
             background: #6c757d; 
         } 
          
         .btn-secondary:hover { 
             background: #545b62; 
             transform: translateY(-1px); 
             box-shadow: 0 4px 8px rgba(108,117,125,0.3); 
         } 
          
         .btn-secondary:active { 
             transform: translateY(0); 
             box-shadow: 0 2px 4px rgba(108,117,125,0.3); 
         } 
          
         /* 모달 버튼 영역 개선 */ 
         .modal-content .btn { 
             min-width: 80px; 
             height: 40px; 
             display: inline-flex; 
             align-items: center; 
             justify-content: center; 
         } 
          
         /* 버튼 컨테이너 스타일 */ 
         .button-container { 
             display: flex; 
             justify-content: flex-end; 
             gap: 10px; 
             margin-top: 25px; 
             padding-top: 20px; 
             border-top: 1px solid #e9ecef; 
         } 
          
         .button-container .btn { 
             min-width: 90px; 
             height: 42px; 
             font-size: 14px; 
             font-weight: 600; 
         } 
          
         .btn-primary { 
             background: #007bff; 
             color: white; 
         } 
          
         .btn-primary:hover { 
             background: #0056b3; 
         } 
          
         /* 모달 내용 스크롤 가능하도록 */ 
         .modal-content { 
             max-height: 85vh; 
             overflow-y: auto; 
             padding-bottom: 20px; 
         } 
          
         /* 폼 그룹 간격 조정 */ 
         .form-group { 
             margin-bottom: 15px; 
         } 
          
         .form-group:last-of-type { 
             margin-bottom: 10px; 
         } 
          
         /* 모달 크기 조정 */ 
         .modal { 
             display: none; 
             position: fixed; 
             z-index: 2000; 
             left: 0; 
             top: 0; 
             width: 100%; 
             height: 100%; 
             background-color: rgba(0,0,0,0.5); 
             overflow-y: auto; 
         } 
          
         .modal-content { 
             background-color: white; 
             margin: 5% auto; 
             padding: 25px; 
             border-radius: 8px; 
             width: 90%; 
             max-width: 500px; 
             box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
             position: relative; 
         } 
          
         /* 버튼 컨테이너가 항상 보이도록 */ 
         .button-container { 
             position: sticky; 
             bottom: 0; 
             background: white; 
             padding: 15px 0; 
             margin-top: 20px; 
             border-top: 1px solid #e9ecef; 
         } 
          
         /* 모달 최대 높이 제한 */ 
         #blasting-modal .modal-content, 
         #measurement-modal .modal-content { 
             max-height: 70vh; 
         } 
          
         #location-modal .modal-content { 
             max-height: 75vh; 
         } 
          
         /* 입력 필드 크기 조정 */ 
         .form-group input, 
         .form-group textarea { 
             padding: 6px 8px; 
             font-size: 13px; 
         } 
          
         /* 라벨 크기 조정 */ 
         .form-group label { 
             font-size: 13px; 
             margin-bottom: 4px; 
         } 
          
         /* 모달 헤더 조정 */ 
         .modal-header { 
             padding-bottom: 15px; 
             margin-bottom: 15px; 
         } 
          
         .modal-title { 
             font-size: 16px; 
         } 
          
         /* 태그 관련 스타일 */ 
         .tag-preview { 
             transition: all 0.2s ease; 
         } 
          
         .tag-preview:hover { 
             transform: scale(1.05); 
             box-shadow: 0 2px 4px rgba(0,0,0,0.2); 
         } 
          
         /* 태그가 있는 마커 스타일 */ 
         .location-marker-with-tags { 
             background: transparent !important; 
             border: none !important; 
         } 
          
         .location-marker-with-tags .leaflet-marker-icon { 
             background: transparent !important; 
             border: none !important; 
         } 
     </style> 
 </head> 
 <body> 
     <div id="map"></div> 
   
      <div class="main-control-panel"> 
         <h3>발파/계측위치 정보</h3> 
          
         <div class="control-section"> 
             <h4>💥 발파위치 정보</h4> 
             <div id="location-info" style="font-size: 12px; color: #666;"> 
                 지도에서 발파 위치를 추가하면 여기에 표시됩니다. 
             </div> 
         </div> 

     </div> 
       
      <!-- 도구 패널 --> 
      <div class="tools-panel"> 
         <h4>🛠️ 도구</h4> 
         <button class="tool-button" id="add-location-btn"> 
             <i>📍</i> 
             위치 추가 
         </button> 
         <button class="tool-button" id="add-blasting-btn"> 
             <i>💥</i> 
             발파 위치 
         </button> 
         <button class="tool-button" id="add-measurement-btn"> 
             <i>📊</i> 
             계측 위치 
         </button> 
         <button class="tool-button" id="measure-distance-btn"> 
             <i>📏</i> 
             거리 계산 
         </button> 
         <button class="tool-button" id="clear-all-btn"> 
             <i>🗑️</i> 
             전체 삭제 
         </button> 

     </div> 
      
     <!-- 위치 추가 모달 --> 
     <div id="location-modal" class="modal"> 
         <div class="modal-content"> 
             <div class="modal-header"> 
                 <span class="modal-title">위치 정보 추가</span> 
                 <span class="close" id="close-location-modal">&times;</span> 
             </div> 
             <form id="location-form"> 
                 <div class="form-group"> 
                     <label for="location-name">위치명</label> 
                     <input type="text" id="location-name" name="location-name" placeholder="위치명을 입력하세요" required> 
                 </div> 
                 <div class="form-group"> 
                     <label for="location-description">설명</label> 
                     <textarea id="location-description" name="location-description" placeholder="위치에 대한 설명을 입력하세요" style="height: 60px;"></textarea> 
                 </div> 
                 <div class="form-group"> 
                     <label for="location-category">카테고리</label> 
                     <input type="text" id="location-category" name="location-category" placeholder="카테고리를 입력하세요 (예: 건물, 시설물, 관심지점)"> 
                 </div> 
                 <div class="form-group"> 
                     <label for="location-tags">태그</label> 
                     <input type="text" id="location-tags" name="location-tags" placeholder="태그를 쉼표로 구분하여 입력하세요 (예: 건설중, 중요, 점검필요)"> 
                     <div id="tags-preview" style="margin-top: 8px; min-height: 20px;"></div> 
                 </div> 
                 <div class="button-container"> 
                     <button type="button" class="btn btn-secondary" id="cancel-location">취소</button> 
                     <button type="submit" class="btn btn-primary" id="save-location">저장</button> 
                 </div> 
             </form> 
         </div> 
     </div> 

     <!-- 발파 정보 모달 --> 
     <div id="blasting-modal" class="modal"> 
         <div class="modal-content"> 
             <div class="modal-header"> 
                 <span class="modal-title">발파 정보 입력</span> 
                 <span class="close" id="close-blasting-modal">&times;</span> 
             </div> 
             <form id="blasting-form"> 
                 <div class="form-group"> 
                     <label>Station 계산 방식</label> 
                     <div style="background: #e7f3ff; padding: 6px; border-radius: 4px; border-left: 3px solid #007bff; font-size: 11px; color: #0056b3;"> 
                         ✅ 기준점 데이터를 사용하여 자동 계산됩니다.<br> 
                         📍 지도에서 클릭하면 정확한 STA 값이 자동으로 표시됩니다. 
                     </div> 
                 </div> 
                 <div class="form-group"> 
                     <label for="blasting-sta">발파위치(Sta.)</label> 
                     <input type="text" id="blasting-sta" name="blasting-sta" placeholder="자동 계산됨" readonly> 
                 </div> 
                 <div class="form-group"> 
                     <label for="blasting-coordinates">발파좌표(X,Y) - EPSG:5186</label> 
                     <input type="text" id="blasting-coordinates" name="blasting-coordinates" placeholder="자동 계산됨" readonly> 
                 </div> 
                 <div class="form-group"> 
                     <label for="blasting-depth">깊이(m)</label> 
                     <input type="number" id="blasting-depth" name="blasting-depth" placeholder="발파 깊이를 입력하세요" step="0.1" min="0" required> 
                 </div> 
                 <div class="form-group"> 
                     <label for="blasting-description">설명</label> 
                     <textarea id="blasting-description" name="blasting-description" placeholder="발파 작업에 대한 설명을 입력하세요" style="height: 60px;"></textarea> 
                 </div> 
                 <div class="button-container"> 
                     <button type="button" class="btn btn-secondary" id="cancel-blasting">취소</button> 
                     <button type="submit" class="btn btn-primary" id="save-blasting">저장</button> 
                 </div> 
             </form> 
         </div> 
     </div> 

     <!-- 계측 정보 모달 --> 
     <div id="measurement-modal" class="modal"> 
         <div class="modal-content"> 
             <div class="modal-header"> 
                 <span class="modal-title">계측 정보 입력</span> 
                 <span class="close" id="close-measurement-modal">&times;</span> 
             </div> 
             <form id="measurement-form"> 
                 <div class="form-group"> 
                     <label for="measurement-sta">계측위치(Sta.)</label> 
                     <input type="text" id="measurement-sta" name="measurement-sta" placeholder="자동 계산됨" readonly> 
                 </div> 
                 <div class="form-group"> 
                     <label for="measurement-coordinates">계측좌표(X,Y) - EPSG:5186</label> 
                     <input type="text" id="measurement-coordinates" name="measurement-coordinates" placeholder="자동 계산됨" readonly> 
                 </div> 
                 <div class="form-group"> 
                     <label for="measurement-description">설명</label> 
                     <textarea id="measurement-description" name="measurement-description" placeholder="계측 작업에 대한 설명을 입력하세요" style="height: 60px;"></textarea> 
                 </div> 
                 <div class="button-container"> 
                     <button type="button" class="btn btn-secondary" id="cancel-measurement">취소</button> 
                     <button type="submit" class="btn btn-primary" id="save-measurement">저장</button> 
                 </div> 
             </form> 
         </div> 
     </div> 
   
     <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script> 
     <script src="https://unpkg.com/proj4@2.11.0/dist/proj4.js"></script> 
     <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script> 
     <!-- DXF 파서 라이브러리들 --> 
     <script src="https://unpkg.com/dxf@4.7.0/dist/dxf.js"></script> 
     <!-- 백업용 기존 파서 --> 
     <script src="https://unpkg.com/dxf-parser@1.1.2/dist/dxf-parser.js"></script> 

     <script> 
         // --- 1. 설정 및 초기화 --- 
         // Google 위성지도 타일 서비스 
         const GOOGLE_SATELLITE_URL = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'; 
         const GOOGLE_HYBRID_URL = 'https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}'; 
         const ESRI_SATELLITE_URL = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'; 

         proj4.defs("EPSG:5186", "+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs"); 
         proj4.defs("EPSG:5179", "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs"); 

         const map = L.map('map', { center: [36.5, 127.5], zoom: 7, maxZoom: 25 }); 
          
         // Google 위성 이미지 (기본) 
         const googleLayer = L.tileLayer(GOOGLE_SATELLITE_URL, { 
             attribution: 'Google Satellite', 
             maxZoom: 25, 
             minZoom: 0 
         }); 
          
         // Google 하이브리드 (라벨 포함) 
         const googleHybridLayer = L.tileLayer(GOOGLE_HYBRID_URL, { 
             attribution: 'Google Hybrid', 
             maxZoom: 25, 
             minZoom: 0 
         }); 
          
         // ESRI 위성 이미지 (백업용) 
         const esriLayer = L.tileLayer(ESRI_SATELLITE_URL, { 
             attribution: 'ESRI World Imagery', 
             maxZoom: 25, 
             minZoom: 0 
         }); 
          
         // 초기 레이어 추가 (Google 위성) 
         googleLayer.addTo(map); 
          
         // 현재 베이스 레이어 설정 
         let currentBaseLayer = googleLayer; 
   
         const dxfLayerGroup = L.layerGroup().addTo(map); 
         const layerGroups = new Map(); // 레이어별 그룹 관리를 위한 Map 
          
         // 레이어 그룹을 베이스 레이어 위에 추가하기 위한 함수 
         function addDXFLayerToMap() { 
             if (map.hasLayer(dxfLayerGroup)) { 
                 map.removeLayer(dxfLayerGroup); 
             } 
             map.addLayer(dxfLayerGroup); 
         } 
          
         // 도구 관련 변수들 
         let isAddingLocation = false; 
         let isMeasuringDistance = false; 
         let isAddingBlasting = false; 
         let isAddingMeasurement = false; 
         let locationMarkers = []; 
         let distanceMarkers = []; 
         let distancePolylines = []; 
         let currentDistancePoints = []; 
          
         // 발파 관련 변수들 
         let blastingMarkers = []; 
         let measurementMarkers = []; 
         let routeData = null; // GeoJSON 노선 데이터 
         let routeLayer = null; // 노선 레이어 
          

          
         // 기준점 데이터 (QGIS에서 생성된 정확한 좌표-STA 쌍) 
         const referencePoints = [ 
             { x: 191210.1879, y: 545380.3588, sta: 27135.5 },    // 27km135.5 
             { x: 191786.3363, y: 544295.5358, sta: 25906.904 },  // 25km906.904 
             { x: 191848.1417, y: 544171.445, sta: 25798.249 },   // 25km798.249 
             { x: 191876.4512, y: 544101.7818, sta: 25693.038 },  // 25km693.038 
             { x: 191942.2975, y: 543890.4457, sta: 25471.646 },  // 25km471.646 
             { x: 191969.7389, y: 543767.1543, sta: 25345.090 },  // 25km345.090 
             { x: 191970.5232, y: 543731.0956, sta: 25309.000 },  // 25km309 
             { x: 191964.6604, y: 543682.5013, sta: 25260.000 },  // 25km260 
             { x: 191959.9417, y: 543662.8322, sta: 25240.000 },  // 25km240 
             { x: 191949.0639, y: 543630.6385, sta: 25205.769 },  // 25km205.769 
             { x: 191929.2976, y: 543589.3926, sta: 25160.000 },  // 25km160 
             { x: 191886.7836, y: 543521.6553, sta: 25080.000 },  // 25km080 
             { x: 191842.3080, y: 543455.1577, sta: 25000.000 }   // 25km000 
         ]; 
          
         // 기본 데이터 자동 로드 (balpa.py에서 전달받은 데이터 사용) 
         console.log('기본 데이터 자동 로드 시작...'); 
          
         // 좌표계 변환을 위한 함수 
         function transformCoordinates(feature) { 
             if (feature.geometry && feature.geometry.coordinates) { 
                 if (feature.geometry.type === 'LineString') { 
                     feature.geometry.coordinates = feature.geometry.coordinates.map(coord => { 
                         // EPSG:5186 → WGS84 변환 
                         const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord); 
                         return [lng, lat]; 
                     }); 
                 } else if (feature.geometry.type === 'Point') { 
                     const coord = feature.geometry.coordinates; 
                     const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord); 
                     return feature.geometry.coordinates = [lng, lat]; 
                 } 
             } 
             return feature; 
         } 
          
         // 첫 번째 노선 데이터 렌더링 
         if (window.defaultRouteData) { 
             console.log('기본 노선 데이터를 balpa.py에서 받았습니다:', window.defaultRouteData); 
              
             // 모든 피처에 대해 좌표계 변환 적용 
             const transformedData = { 
                 ...window.defaultRouteData, 
                 features: window.defaultRouteData.features.map(transformCoordinates) 
             }; 
              
             routeData = transformedData; 
             console.log('기본 노선 데이터 로드됨 (좌표계 변환 완료):', transformedData); 
              
             // 변환된 데이터로 노선 레이어 생성 
             routeLayer = L.geoJSON(transformedData, { 
                 style: { 
                     color: '#ff6b35', 
                     weight: 3, 
                     opacity: 0.8 
                 } 
             }).addTo(map); 
              
             // 노선에 맞춰 지도 뷰 조정 
             if (transformedData.features && transformedData.features.length > 0) { 
                 map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }); 
             } 
         } else { 
             console.log('기본 노선 데이터가 없습니다. 파일 업로드가 필요합니다.'); 
         } 
          
         // 기본 DXF 파일 자동 로드 (balpa.py에서 전달받은 데이터 사용) 
         console.log('DXF 데이터 확인:', { 
             hasDefaultDxfContent: !!window.defaultDxfContent, 
             defaultDxfContentLength: window.defaultDxfContent ? window.defaultDxfContent.length : 0, 
             defaultDxfContentPreview: window.defaultDxfContent ? window.defaultDxfContent.substring(0, 200) : '없음' 
         }); 
          
         if (window.defaultDxfContent) { 
             console.log('기본 DXF 파일을 balpa.py에서 받았습니다. 파싱 시작...'); 
             console.log('DXF 내용 길이:', window.defaultDxfContent.length); 
             console.log('DXF 내용 시작 부분:', window.defaultDxfContent.substring(0, 100)); 
              
             // DXF 파싱 및 렌더링 
             try { 
                 console.log('DXF 파서 확인:', { 
                     hasDXF: typeof DXF !== 'undefined', 
                     hasHelper: typeof DXF !== 'undefined' && DXF.Helper, 
                     DXF: typeof DXF !== 'undefined' ? DXF : 'undefined' 
                 }); 
                  
                 // 새로운 DXF 파서 시도 
                 let CadData; 
                 if (typeof DXF !== 'undefined' && DXF.Helper) { 
                     try { 
                         console.log('새로운 DXF 파서로 시도 중...'); 
                         const helper = new DXF.Helper(window.defaultDxfContent); 
                         CadData = helper.getCadData(); 
                         console.log('새로운 DXF 파서로 성공:', CadData); 
                         console.log('CadData 구조:', { 
                             hasEntities: !!CadData.entities, 
                             entitiesCount: CadData.entities ? CadData.entities.length : 0, 
                             entitiesPreview: CadData.entities ? CadData.entities.slice(0, 3) : '없음' 
                         }); 
                     } catch (newParserError) { 
                         console.log('새로운 파서 실패, 기존 파서 시도:', newParserError); 
                         throw newParserError; 
                     } 
                 } else { 
                     throw new Error('DXF.Helper를 찾을 수 없습니다'); 
                 } 

                 if (CadData && CadData.entities && CadData.entities.length > 0) { 
                     // 좌표계 자동 감지 
                     const firstPoint = findFirstPoint(CadData.entities); 
                     const detectedEPSG = detectCoordinateSystem(firstPoint); 
                     console.log('기본 DXF 파일 - 좌표계 감지: EPSG:' + detectedEPSG); 

                     // 각 도형을 지도에 그리기 
                     const allLatLngs = []; 
                     console.log('기본 DXF 파일 - 총 엔티티 수:', CadData.entities.length); 
                      
                     for (const entity of CadData.entities) { 
                         const geometry = entityToLatLngs(entity, detectedEPSG); 
                         if (geometry.latlngs.length > 0) { 
                             const layerName = entity.layer || '0'; 
                             const style = getStyleForEntity(entity, CadData.tables ? CadData.tables.layers : null); 
                              
                             const layerGroup = getOrCreateLayerGroup(layerName, style.color); 
                              
                             if(geometry.type === 'polyline') { 
                                 L.polyline(geometry.latlngs, style).addTo(layerGroup); 
                             } else if(geometry.type === 'circle') { 
                                 L.circle(geometry.latlngs[0], { ...style, radius: geometry.radius }).addTo(layerGroup); 
                             } else if(geometry.type === 'hatch') { 
                                 L.polygon(geometry.latlngs, { 
                                     fillColor: '#FFFF00', 
                                     color: '#FFD700', 
                                     weight: 2, 
                                     opacity: 0.3, 
                                     fillOpacity: 0.1 
                                 }).addTo(layerGroup); 
                             } else if(geometry.type === 'text') { 
                                 const textContent = entity.text || entity.textString || 'TEXT'; 
                                  
                                 const textDiv = L.divIcon({ 
                                     className: 'text-marker', 
                                     html: '<div style="color: black; padding: 2px 6px; font-size: 12px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-weight: bold;">' + textContent + '</div>', 
                                     iconSize: [0, 0], 
                                     iconAnchor: [0, 0] 
                                 }); 
                                  
                                 const textMarker = L.marker(geometry.latlngs[0], { 
                                     icon: textDiv, 
                                     interactive: true 
                                 }).addTo(layerGroup); 
                                  
                                 textMarker.bindPopup( 
                                     '<div style="min-width: 150px;">' + 
                                     '<strong>텍스트:</strong> ' + textContent + '<br>' + 
                                     '<strong>레이어:</strong> ' + layerName + '<br>' + 
                                     '<strong>좌표:</strong> ' + geometry.latlngs[0][0].toFixed(6) + ', ' + geometry.latlngs[0][1].toFixed(6) + 
                                     '</div>' 
                                 ); 
                             } else if(geometry.type === 'point') { 
                                 L.circleMarker(geometry.latlngs[0], { 
                                     radius: 3, 
                                     fillColor: '#ff0000', 
                                     color: '#000', 
                                     weight: 1, 
                                     opacity: 1, 
                                     fillOpacity: 0.8 
                                 }).addTo(layerGroup); 
                             } 
                             allLatLngs.push(...geometry.latlngs); 
                         } 
                     } 

                     if (allLatLngs.length > 0) { 
                         // DXF 데이터가 있으면 지도 뷰 조정 
                         if (routeData && routeData.features && routeData.features.length > 0) { 
                             // 노선과 DXF 데이터를 모두 포함하는 뷰로 조정 
                             const allBounds = L.latLngBounds(allLatLngs); 
                             const routeBounds = routeLayer.getBounds(); 
                             const combinedBounds = allBounds.extend(routeBounds); 
                             map.fitBounds(combinedBounds, { padding: [50, 50] }); 
                         } else { 
                             map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] }); 
                         } 
                         console.log('기본 DXF 파일 렌더링 완료!'); 
                     } 
                 } 
             } catch (error) { 
                 console.log('기본 DXF 파일 파싱 실패:', error); 
             } 
         } else { 
             console.log('기본 DXF 파일이 없습니다. 파일 업로드가 필요합니다.'); 
         } 
          
         // 도구 버튼 이벤트 리스너 
         document.getElementById('add-location-btn').addEventListener('click', function() { 
             toggleLocationMode(); 
         }); 
          
         document.getElementById('measure-distance-btn').addEventListener('click', function() { 
             toggleDistanceMode(); 
         }); 
          
         document.getElementById('add-blasting-btn').addEventListener('click', function() { 
             toggleBlastingMode(); 
         }); 
          
         document.getElementById('add-measurement-btn').addEventListener('click', function() { 
             toggleMeasurementMode(); 
         }); 
          
         document.getElementById('clear-all-btn').addEventListener('click', function() { 
             if (confirm('모든 위치 마커와 거리 측정을 삭제하시겠습니까?')) { 
                 clearAllMarkers(); 
             } 
         }); 
          

          
         // 모달 관련 이벤트 리스너 
         document.getElementById('close-location-modal').addEventListener('click', function() { 
             closeLocationModal(); 
         }); 
          
         document.getElementById('cancel-location').addEventListener('click', function() { 
             closeLocationModal(); 
         }); 
          
         // 발파 모달 이벤트 리스너 
         document.getElementById('close-blasting-modal').addEventListener('click', function() { 
             closeBlastingModal(); 
         }); 
          
         document.getElementById('cancel-blasting').addEventListener('click', function() { 
             closeBlastingModal(); 
         }); 
          
         // 계측 모달 이벤트 리스너 
         document.getElementById('close-measurement-modal').addEventListener('click', function() { 
             closeMeasurementModal(); 
         }); 
          
         document.getElementById('cancel-measurement').addEventListener('click', function() { 
             closeMeasurementModal(); 
         }); 
          

          
         // 태그 입력 시 실시간 미리보기 
         document.getElementById('location-tags').addEventListener('input', function() { 
             updateTagsPreview(); 
         }); 
          
         // 태그 미리보기 업데이트 
         function updateTagsPreview() { 
             const tagsInput = document.getElementById('location-tags'); 
             const tagsPreview = document.getElementById('tags-preview'); 
             const tags = tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag); 
              
             if (tags.length > 0) { 
                 const tagsHTML = tags.map(tag =>  
                     `<span class="tag-preview" style="display: inline-block; background: #007bff; color: white; padding: 2px 8px; margin: 2px; border-radius: 12px; font-size: 11px;">${tag}</span>` 
                 ).join(''); 
                 tagsPreview.innerHTML = tagsHTML; 
             } else { 
                 tagsPreview.innerHTML = ''; 
             } 
         } 
          
         // 위치 추가 모드 토글 
         function toggleLocationMode() { 
             if (isAddingLocation) { 
                 isAddingLocation = false; 
                 document.getElementById('add-location-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
             } else { 
                 // 다른 모드 비활성화 
                 isMeasuringDistance = false; 
                 document.getElementById('measure-distance-btn').classList.remove('active'); 
                  
                 // 위치 추가 모드 활성화 
                 isAddingLocation = true; 
                 document.getElementById('add-location-btn').classList.add('active'); 
                 map.getContainer().style.cursor = 'crosshair'; 
             } 
         } 
          
         // 발파 모드 토글 
         function toggleBlastingMode() { 
             if (isAddingBlasting) { 
                 isAddingBlasting = false; 
                 document.getElementById('add-blasting-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
             } else { 
                 // 다른 모드 비활성화 
                 isAddingLocation = false; 
                 isMeasuringDistance = false; 
                 isAddingMeasurement = false; 
                 document.getElementById('add-location-btn').classList.remove('active'); 
                 document.getElementById('measure-distance-btn').classList.remove('active'); 
                 document.getElementById('add-measurement-btn').classList.remove('active'); 
                  
                 // 발파 모드 활성화 
                 isAddingBlasting = true; 
                 document.getElementById('add-blasting-btn').classList.add('active'); 
                 map.getContainer().style.cursor = 'crosshair'; 
             } 
         } 
          
         // 계측 모드 토글 
         function toggleMeasurementMode() { 
             if (isAddingMeasurement) { 
                 isAddingMeasurement = false; 
                 document.getElementById('add-measurement-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
             } else { 
                 // 다른 모드 비활성화 
                 isAddingLocation = false; 
                 isMeasuringDistance = false; 
                 isAddingBlasting = false; 
                 document.getElementById('add-location-btn').classList.remove('active'); 
                 document.getElementById('measure-distance-btn').classList.remove('active'); 
                 document.getElementById('add-blasting-btn').classList.remove('active'); 
                  
                 // 계측 모드 활성화 
                 isAddingMeasurement = true; 
                 document.getElementById('add-measurement-btn').classList.add('active'); 
                 map.getContainer().style.cursor = 'crosshair'; 
             } 
         } 
          
         // 거리 계산 모드 토글 
         function toggleDistanceMode() { 
             if (isMeasuringDistance) { 
                 isMeasuringDistance = false; 
                 document.getElementById('measure-distance-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
                 finishDistanceMeasurement(); 
             } else { 
                 // 다른 모드 비활성화 
                 isAddingLocation = false; 
                 isAddingBlasting = false; 
                 isAddingMeasurement = false; 
                 document.getElementById('add-location-btn').classList.remove('active'); 
                 document.getElementById('add-blasting-btn').classList.remove('active'); 
                 document.getElementById('add-measurement-btn').classList.remove('active'); 
                  
                 // 거리 계산 모드 활성화 
                 isMeasuringDistance = true; 
                 document.getElementById('measure-distance-btn').classList.add('active'); 
                 map.getContainer().style.cursor = 'crosshair'; 
                 startDistanceMeasurement(); 
             } 
         } 
          
         // 거리 계산 시작 
         function startDistanceMeasurement() { 
             currentDistancePoints = []; 
             map.on('click', onMapClickForDistance); 
         } 
          
         // 거리 계산을 위한 지도 클릭 이벤트 
         function onMapClickForDistance(e) { 
             if (!isMeasuringDistance) return; 
              
             const latlng = e.latlng; 
             currentDistancePoints.push(latlng); 
              
             // 마커 추가 
             const marker = L.marker(latlng, { 
                 icon: L.divIcon({ 
                     className: 'distance-marker', 
                     html: `<div style="background: #007bff; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">${currentDistancePoints.length}</div>`, 
                     iconSize: [20, 20] 
                 }) 
             }).addTo(map); 
              
             distanceMarkers.push(marker); 
              
             // 선 그리기 
             if (currentDistancePoints.length > 1) { 
                 const polyline = L.polyline([currentDistancePoints[currentDistancePoints.length - 2], latlng], { 
                     color: '#007bff', 
                     weight: 3, 
                     opacity: 0.8 
                 }).addTo(map); 
                  
                 distancePolylines.push(polyline); 
                  
                 // 거리 표시 
                 const distance = calculateDistance(currentDistancePoints[currentDistancePoints.length - 2], latlng); 
                 L.tooltip({ 
                     permanent: true, 
                     direction: 'center' 
                 }) 
                 .setContent(`${distance.toFixed(2)}m`) 
                 .setLatLng([(currentDistancePoints[currentDistancePoints.length - 2].lat + latlng.lat) / 2, (currentDistancePoints[currentDistancePoints.length - 2].lng + latlng.lng) / 2]) 
                 .addTo(map); 
             } 
         } 
          
         // 거리 계산 완료 
         function finishDistanceMeasurement() { 
             map.off('click', onMapClickForDistance); 
              
             if (currentDistancePoints.length > 1) { 
                 const totalDistance = calculateTotalDistance(); 
                 alert(`총 거리: ${totalDistance.toFixed(2)}m`); 
             } 
         } 
          
         // 두 점 사이의 거리 계산 (미터) 
         function calculateDistance(point1, point2) { 
             return L.latLng(point1.lat, point1.lng).distanceTo(L.latLng(point2.lat, point2.lng)); 
         } 
          
         // 총 거리 계산 
         function calculateTotalDistance() { 
             let total = 0; 
             for (let i = 1; i < currentDistancePoints.length; i++) { 
                 total += calculateDistance(currentDistancePoints[i-1], currentDistancePoints[i]); 
             } 
             return total; 
         } 
          
         // 위치 추가를 위한 지도 클릭 이벤트 
         map.on('click', function(e) { 
             // 마지막 클릭 위치 저장 (Station 시작점 변경 시 STA. 재계산용) 
             window.lastClickedLatLng = e.latlng; 
              
             if (isAddingLocation) { 
                 showLocationModal(e.latlng); 
             } else if (isAddingBlasting) { 
                 showBlastingModal(e.latlng); 
             } else if (isAddingMeasurement) { 
                 showMeasurementModal(e.latlng); 
             } 
         }); 
          
         // 위치 추가 모달 표시 
         function showLocationModal(latlng) { 
             document.getElementById('location-modal').style.display = 'block'; 
              
             // 폼 제출 이벤트 
             document.getElementById('location-form').onsubmit = function(e) { 
                 e.preventDefault(); 
                 addLocationMarker(latlng); 
                 closeLocationModal(); 
             }; 
         } 
          
         // 발파 모달 표시 
         function showBlastingModal(latlng) { 
             // WGS84 좌표를 EPSG:5186으로 변환 
             const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]); 
             const coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`; 
              
             // 기준점 데이터를 사용하여 STA 값 자동 계산 
             const sta = calculateSTA(latlng); 
              
             document.getElementById('blasting-coordinates').value = coordinates; 
             document.getElementById('blasting-sta').value = sta; 
              
             document.getElementById('blasting-modal').style.display = 'block'; 
              
             // 폼 제출 이벤트 
             document.getElementById('blasting-form').onsubmit = function(e) { 
                 e.preventDefault(); 
                 addBlastingMarker(latlng); 
                 closeBlastingModal(); 
             }; 
         } 
          
         // 계측 모달 표시 
         function showMeasurementModal(latlng) { 
             // WGS84 좌표를 EPSG:5186으로 변환 
             const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]); 
             const coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`; 
              
             // 기준점 데이터를 사용하여 STA 값 자동 계산 
             const sta = calculateSTA(latlng); 
              
             document.getElementById('measurement-coordinates').value = coordinates; 
             document.getElementById('measurement-sta').value = sta; 
              
             document.getElementById('measurement-modal').style.display = 'block'; 
              
             // 폼 제출 이벤트 
             document.getElementById('measurement-form').onsubmit = function(e) { 
                 e.preventDefault(); 
                 addMeasurementMarker(latlng); 
                 closeMeasurementModal(); 
             }; 
         } 
          
         // 위치 추가 모달 닫기 
         function closeLocationModal() { 
             document.getElementById('location-modal').style.display = 'none'; 
             document.getElementById('location-form').reset(); 
         } 
          
         // 발파 모달 닫기 
         function closeBlastingModal() { 
             document.getElementById('blasting-modal').style.display = 'none'; 
             document.getElementById('blasting-form').reset(); 
         } 
          
         // 계측 모달 닫기 
         function closeMeasurementModal() { 
             document.getElementById('measurement-modal').style.display = 'none'; 
             document.getElementById('measurement-form').reset(); 
         } 
          

          

          

          
         // 위치 마커 추가 
         function addLocationMarker(latlng) { 
             try { 
                 // 필수 필드 값 가져오기 
                 const name = document.getElementById('location-name').value.trim(); 
                 const description = document.getElementById('location-description').value.trim(); 
                 const category = document.getElementById('location-category').value.trim(); 
                 const tags = document.getElementById('location-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag); 
                  
                 // 필수 필드 검증 
                 if (!name) { 
                     alert('❌ 위치명을 입력해주세요.'); 
                     return; 
                 } 
                  
                 // 위치 마커 생성 
                 const markerIcon = L.divIcon({ 
                     className: 'location-marker', 
                     html: `<div style="background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold;">📍</div>`, 
                     iconSize: [24, 24] 
                 }); 
                  
                 const marker = L.marker(latlng, { 
                     icon: markerIcon 
                 }).addTo(map); 
                  
                 // 태그가 있는 경우 지도에 직접 텍스트 라벨 추가 
                 if (tags.length > 0) { 
                     const tagLabel = L.divIcon({ 
                         className: 'tag-label', 
                         html: ` 
                             <div style="background: white; color: #333; padding: 6px 10px; border-radius: 6px; font-size: 13px; font-weight: bold; white-space: nowrap; box-shadow: 0 3px 8px rgba(0,0,0,0.3); border: 2px solid #6f42c1; text-align: center; min-width: 60px;"> 
                                 ${tags[0]} 
                             </div> 
                         `, 
                         iconSize: [0, 0], 
                         iconAnchor: [0, 0] 
                     }); 
                      
                     const tagMarker = L.marker(latlng, { 
                         icon: tagLabel, 
                         interactive: false 
                     }).addTo(map); 
                      
                     // 태그 라벨을 마커 오른쪽에 배치 
                     tagMarker.setLatLng([ 
                         latlng.lat, 
                         latlng.lng + 0.00015 // 마커 오른쪽에 적절한 오프셋 
                     ]); 
                      
                     // 태그 마커를 위치 마커와 함께 관리 
                     locationMarkers.push({ marker: marker, tagMarker: tagMarker }); 
                 } else { 
                     locationMarkers.push({ marker: marker, tagMarker: null }); 
                 } 
                  
                 // 팝업 정보 추가 
                 const popupContent = ` 
                     <div style="min-width: 200px;"> 
                         <h4 style="margin: 0 0 10px 0; color: #007bff;">${name}</h4> 
                         ${category ? `<p style="margin: 5px 0; color: #666;"><strong>카테고리:</strong> ${category}</p>` : ''} 
                         ${description ? `<p style="margin: 5px 0; color: #333;">${description}</p>` : ''} 
                         ${tags.length > 0 ? ` 
                             <div style="margin: 10px 0;"> 
                                 <p style="margin: 5px 0; color: #666;"><strong>태그:</strong></p> 
                                 <div style="display: flex; flex-wrap: wrap; gap: 5px;"> 
                                     ${tags.map(tag => `<span style="background: #ff6b35; color: white; padding: 3px 8px; border-radius: 12px; font-size: 11px;">${tag}</span>`).join('')}</div> 
                             </div> 
                         ` : ''} 
                         <p style="margin: 5px 0; font-size: 12px; color: #999;"> 
                             좌표: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)} 
                         </p> 
                         <button onclick="removeLocationMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">삭제</button> 
                     </div> 
                 `; 
                  
                 marker.bindPopup(popupContent); 
                  
                 // 위치 추가 모드 비활성화 
                 isAddingLocation = false; 
                 document.getElementById('add-location-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
                  
                 // 위치 정보 업데이트 
                 updateLocationInfo(); 
                  
                 // 성공 메시지 표시 
                 alert(`📍 위치가 성공적으로 추가되었습니다!\n\n위치명: ${name}\n좌표: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`); 
                  
                 // 모달 닫기 
                 closeLocationModal(); 
                  
             } catch (error) { 
                 console.error('위치 마커 추가 중 오류:', error); 
                 alert('❌ 위치 추가 중 오류가 발생했습니다: ' + error.message); 
             } 
         } 
          
         // 발파 마커 추가 
         async function addBlastingMarker(latlng) { 
             try { 
                 // 필수 필드 값 가져오기 
                 const blastingSta = document.getElementById('blasting-sta').value.trim(); 
                 const blastingCoordinates = document.getElementById('blasting-coordinates').value.trim(); 
                 const blastingDepth = parseFloat(document.getElementById('blasting-depth').value); 
                 const blastingDescription = document.getElementById('blasting-description').value.trim(); 
                  
                 // 자동으로 발파 ID 생성 (타임스탬프 기반) 
                 const blastingId = 'BP_' + Date.now(); 
                  
                 if (!blastingSta) { 
                     alert('❌ STA 값이 계산되지 않았습니다. 지도에서 다시 클릭해주세요.'); 
                     return; 
                 } 
                  
                 if (isNaN(blastingDepth) || blastingDepth <= 0) { 
                     alert('❌ 유효한 깊이를 입력해주세요.'); 
                     return; 
                 } 
                  
                 // WGS84 좌표를 EPSG:5186으로 변환하여 저장 
                 const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]); 
                 const epsg5186Coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`; 
                  
                 // 발파 마커 생성 (투명 배경) 
                 const markerIcon = L.divIcon({ 
                     className: 'blasting-marker', 
                     html: `<div style="background: transparent; color: #dc3545; border: 3px solid #dc3545; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold;">💥</div>`, 
                     iconSize: [28, 28] 
                 }); 
                  
                 const marker = L.marker(latlng, { 
                     icon: markerIcon 
                 }).addTo(map); 
                  
                 // 발파 정보를 마커에 저장 
                 marker.blastingData = { 
                     id: blastingId, 
                     sta: blastingSta, 
                     coordinates: epsg5186Coordinates, 
                     depth: blastingDepth, 
                     description: blastingDescription, 
                     latlng: latlng, 
                     epsg5186: { x: x, y: y } 
                 }; 
                  
                 // Streamlit 세션 상태에 발파위치 정보 저장 
                 const blastingLocationData = { 
                     id: blastingId, 
                     sta: blastingSta, 
                     coordinates: epsg5186Coordinates, 
                     depth: blastingDepth, 
                     description: blastingDescription, 
                     timestamp: new Date().toISOString() 
                 }; 
                  
                 // 콘솔에 로그 출력 
                 console.log('💥 발파위치 정보:', blastingLocationData); 
                  
                 // 팝업 정보 추가 
                 const popupContent = ` 
                     <div style="min-width: 250px;"> 
                         <h4 style="margin: 0 0 10px 0; color: #dc3545;">💥 발파 위치</h4> 
                         <p style="margin: 5px 0; color: #333;"><strong>발파 ID:</strong> ${blastingId}</p> 
                         <p style="margin: 5px 0; color: #333;"><strong>STA.:</strong> ${blastingSta}</p> 
                         <p style="margin: 5px 0; color: #333;"><strong>좌표:</strong> ${epsg5186Coordinates}</p> 
                         <p style="margin: 5px 0; color: #333;"><strong>깊이:</strong> ${blastingDepth}m</p> 
                         ${blastingDescription ? `<p style="margin: 5px 0; color: #333;"><strong>설명:</strong> ${blastingDescription}</p>` : ''} 
                         <button onclick="removeBlastingMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">삭제</button> 
                     </div> 
                 `; 
                  
                 marker.bindPopup(popupContent); 
                  
                 // 발파 마커 배열에 추가 
                 blastingMarkers.push(marker); 
                  
                 // 발파 추가 모드 비활성화 
                 isAddingBlasting = false; 
                 document.getElementById('add-blasting-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
                  
                 // 발파 정보 업데이트 
                 updateBlastingInfo(); 
                  
                 // 성공 메시지 표시 
                 alert(`💥 발파위치가 성공적으로 추가되었습니다!\n\nID: ${blastingId}\nSTA.: ${blastingSta}\n좌표: ${epsg5186Coordinates}\n깊이: ${blastingDepth}m`); 
                  
                 // Supabase에 발파위치 데이터 저장 
                 try { 
                     if (!window.supabaseClient) { 
                         throw new Error('Supabase 클라이언트가 초기화되지 않았습니다.'); 
                     } 
                      
                     console.log('🔄 Supabase에 발파위치 저장 시도:', { 
                         location_id: blastingId, 
                         sta: blastingSta, 
                         coordinates_x: x, 
                         coordinates_y: y, 
                         depth: blastingDepth, 
                         description: blastingDescription 
                     }); 
                      
                     const { data, error } = await window.supabaseClient 
                         .from('blasting_locations') 
                         .insert([ 
                             { 
                                 location_id: blastingId, 
                                 sta: blastingSta, 
                                 coordinates_x: x, 
                                 coordinates_y: y, 
                                 depth: blastingDepth, 
                                 description: blastingDescription 
                             } 
                         ]) 
                         .select(); 
                      
                     if (error) { 
                         console.error('❌ Supabase 저장 오류:', error); 
                         alert('❌ 데이터베이스 저장 중 오류가 발생했습니다: ' + error.message); 
                     } else { 
                         console.log('✅ Supabase 저장 성공:', data); 
                         alert('✅ 발파위치가 데이터베이스에 저장되었습니다!'); 
                          
                         // 즉시 Streamlit으로 발파위치 데이터 전송 
                         sendBlastingLocationsToStreamlit(); 
                          
                         // 사용자에게 동기화 안내 
                         setTimeout(() => { 
                             alert('💡 발파위치가 추가되었습니다!\n\nStreamlit 화면에서 "🔄 즉시 동기화" 버튼을 클릭하여 최신 데이터를 확인하세요.'); 
                         }, 1000); 
                     } 
                 } catch (e) { 
                     console.error('❌ Supabase 저장 중 예외 발생:', e); 
                     alert('❌ 데이터베이스 저장 중 오류가 발생했습니다: ' + e.message); 
                 } 
                  
                 // 모달 닫기 
                 closeBlastingModal(); 
                  
             } catch (error) { 
                 console.error('발파 마커 추가 중 오류:', error); 
                 alert('❌ 발파위치 추가 중 오류가 발생했습니다: ' + error.message); 
             } 
         } 
          
         // 계측 마커 추가 
         function addMeasurementMarker(latlng) { 
             try { 
                 // 필수 필드 값 가져오기 
                 const measurementSta = document.getElementById('measurement-sta').value.trim(); 
                 const measurementCoordinates = document.getElementById('measurement-coordinates').value.trim(); 
                 const measurementDescription = document.getElementById('measurement-description').value.trim(); 
                  
                 // 필수 필드 검증 
                 if (!measurementSta) { 
                     alert('❌ STA 값이 계산되지 않았습니다. 지도에서 다시 클릭해주세요.'); 
                     return; 
                 } 
                  
                 // WGS84 좌표를 EPSG:5186으로 변환하여 저장 
                 const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]); 
                 const epsg5186Coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`; 
                  
                 // 계측 마커 생성 (파란색) 
                 const markerIcon = L.divIcon({ 
                     className: 'measurement-marker', 
                     html: `<div style="background: #007bff; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold;">📊</div>`, 
                     iconSize: [28, 28] 
                 }); 
                  
                 const marker = L.marker(latlng, { 
                     icon: markerIcon 
                 }).addTo(map); 
                  
                 // 계측 정보를 마커에 저장 
                 marker.measurementData = { 
                     sta: measurementSta, 
                     coordinates: epsg5186Coordinates, 
                     description: measurementDescription, 
                     latlng: latlng, 
                     epsg5186: { x: x, y: y } 
                 }; 
                  
                 // 콘솔에 로그 출력 
                 console.log('📊 계측위치 정보:', marker.measurementData); 
                  
                 // 팝업 정보 추가 
                 const popupContent = ` 
                     <div style="min-width: 250px;"> 
                         <h4 style="margin: 0 0 10px 0; color: #007bff;">📊 계측 위치</h4> 
                         <p style="margin: 5px 0; color: #333;"><strong>STA.:</strong> ${measurementSta}</p> 
                         <p style="margin: 5px 0; color: #333;"><strong>좌표:</strong> ${epsg5186Coordinates}</p> 
                         ${measurementDescription ? `<p style="margin: 5px 0; color: #333;"><strong>설명:</strong> ${measurementDescription}</p>` : ''} 
                         <button onclick="removeMeasurementMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">삭제</button> 
                     </div> 
                 `; 
                  
                 marker.bindPopup(popupContent); 
                  
                 // 계측 마커 배열에 추가 
                 measurementMarkers.push(marker); 
                  
                 // 계측 추가 모드 비활성화 
                 isAddingMeasurement = false; 
                 document.getElementById('add-measurement-btn').classList.remove('active'); 
                 map.getContainer().style.cursor = ''; 
                  
                 // 발파 정보 업데이트 (거리 계산 포함) 
                 updateBlastingInfo(); 
                  
                 // 성공 메시지 표시 
                 alert(`📊 계측위치가 성공적으로 추가되었습니다!\n\nSTA.: ${measurementSta}\n좌표: ${epsg5186Coordinates}`); 
                  
                 // 모달 닫기 
                 closeMeasurementModal(); 
                  
             } catch (error) { 
                 console.error('계측 마커 추가 중 오류:', error); 
                 alert('❌ 계측위치 추가 중 오류가 발생했습니다: ' + error.message); 
             } 
         } 
          
         // 위치 마커 삭제 (전역 함수로 등록) 
         window.removeLocationMarker = function(button) { 
             const marker = button.closest('.leaflet-popup-content').__marker; 
             if (marker) { 
                 // 위치 마커와 태그 마커 모두 찾아서 삭제 
                 const locationData = locationMarkers.find(item => item.marker === marker); 
                 if (locationData) { 
                     map.removeLayer(locationData.marker); 
                     if (locationData.tagMarker) { 
                         map.removeLayer(locationData.tagMarker); 
                     } 
                      
                     const index = locationMarkers.indexOf(locationData); 
                     if (index > -1) { 
                         locationMarkers.splice(index, 1); 
                     } 
                      
                     // 위치 정보 업데이트 
                     updateLocationInfo(); 
                 } 
             } 
         }; 
          
         // 발파 마커 삭제 (전역 함수로 등록) 
         window.removeBlastingMarker = function(button) { 
             const marker = button.closest('.leaflet-popup-content').__marker; 
             if (marker) { 
                 map.removeLayer(marker); 
                  
                 const index = blastingMarkers.indexOf(marker); 
                 if (index > -1) { 
                     blastingMarkers.splice(index, 1); 
                 } 
                  
                 // 발파 정보 업데이트 
                 updateBlastingInfo(); 
             } 
         }; 
          
         // 계측 마커 삭제 (전역 함수로 등록) 
         window.removeMeasurementMarker = function(button) { 
             const marker = button.closest('.leaflet-popup-content').__marker; 
             if (marker) { 
                 map.removeLayer(marker); 
                  
                 const index = measurementMarkers.indexOf(marker); 
                 if (index > -1) { 
                     measurementMarkers.splice(index, 1); 
                 } 
                  
                 // 발파 정보 업데이트 
                 updateBlastingInfo(); 
             } 
         }; 
          
         // 전체 마커 삭제 
         function clearAllMarkers() { 
             // 위치 마커 삭제 
             locationMarkers.forEach(item => { 
                 map.removeLayer(item.marker); 
                 if (item.tagMarker) { 
                     map.removeLayer(item.tagMarker); 
                 } 
             }); 
             locationMarkers = []; 
              
             // 발파 마커 삭제 
             blastingMarkers.forEach(marker => map.removeLayer(marker)); 
             blastingMarkers = []; 
              
             // 계측 마커 삭제 
             measurementMarkers.forEach(marker => map.removeLayer(marker)); 
             measurementMarkers = []; 
              
             // 거리 측정 마커 삭제 
             distanceMarkers.forEach(marker => map.removeLayer(marker)); 
             distancePolylines.forEach(polyline => map.removeLayer(polyline)); 
             distanceMarkers = []; 
             distancePolylines = []; 
             currentDistancePoints = []; 
              
             // 정보 업데이트 
             updateLocationInfo(); 
             updateBlastingInfo(); 
              
             // 모드 비활성화 
             isAddingLocation = false; 
             isMeasuringDistance = false; 
             isAddingBlasting = false; 
             isAddingMeasurement = false; 
             document.getElementById('add-location-btn').classList.remove('active'); 
             document.getElementById('measure-distance-btn').classList.remove('active'); 
             document.getElementById('add-blasting-btn').classList.remove('active'); 
             document.getElementById('add-measurement-btn').classList.remove('active'); 
             map.getContainer().style.cursor = ''; 
         } 
          
         // 위치 정보 업데이트 (updateBlastingInfo로 통합됨) 
         function updateLocationInfo() { 
             // updateBlastingInfo 함수가 모든 정보를 통합하여 표시하므로 이 함수는 더 이상 사용하지 않음 
             updateBlastingInfo(); 
         } 
          
         // 발파 정보 업데이트 
         function updateBlastingInfo() { 
             try { 
                 // blasting-info 요소가 없으면 location-info에 통합하여 표시 
                 const locationInfo = document.getElementById('location-info'); 
                 if (!locationInfo) { 
                     console.warn('location-info 요소를 찾을 수 없습니다.'); 
                     return; 
                 } 
                  
                 let infoHTML = ''; 
                  
                 // 위치 마커 정보 
                 if (locationMarkers.length > 0) { 
                     infoHTML += '<h5 style="margin: 10px 0 5px 0; color: #28a745;">📍 위치 정보</h5>'; 
                     locationMarkers.forEach((item, index) => { 
                         const latlng = item.marker.getLatLng(); 
                         infoHTML += ` 
                             <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #28a745;"> 
                                 <div style="font-weight: bold; color: #333;">위치 ${index + 1}</div> 
                                 <div style="font-size: 11px; color: #666;">좌표: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}</div> 
                             </div> 
                         `; 
                     }); 
                 } 
                  
                 // 발파 마커 정보 
                 if (blastingMarkers.length > 0) { 
                     infoHTML += '<h5 style="margin: 15px 0 5px 0; color: #dc3545;">💥 발파 위치</h5>'; 
                     blastingMarkers.forEach((marker, index) => { 
                         const data = marker.blastingData; 
                         infoHTML += ` 
                             <div style="padding: 8px; margin: 5px 0; background: #fff5f5; border-radius: 4px; border-left: 3px solid #dc3545;"> 
                                 <div style="font-weight: bold; color: #333;">발파 ${index + 1}</div> 
                                 <div style="font-size: 11px; color: #666;">ID: ${data.id}</div> 
                                 <div style="font-size: 11px; color: #666;">STA.: ${data.sta}</div> 
                                 <div style="font-size: 11px; color: #666;">깊이: ${data.depth}m</div> 
                             </div> 
                         `; 
                     }); 
                 } 
                  
                 // 계측 마커 정보 
                 if (measurementMarkers.length > 0) { 
                     infoHTML += '<h5 style="margin: 15px 0 5px 0; color: #007bff;">📊 계측 위치</h5>'; 
                     measurementMarkers.forEach((marker, index) => { 
                         const data = marker.measurementData; 
                         infoHTML += ` 
                             <div style="padding: 8px; margin: 5px 0; background: #f0f8ff; border-radius: 4px; border-left: 3px solid #007bff;"> 
                                 <div style="font-weight: bold; color: #333;">계측 ${index + 1}</div> 
                                 <div style="font-size: 11px; color: #666;">STA.: ${data.sta}</div> 
                             </div> 
                         `; 
                     }); 
                 } 
                  
                 // 거리 계산 결과 
                 if (blastingMarkers.length > 0 && measurementMarkers.length > 0) { 
                     infoHTML += '<h5 style="margin: 15px 0 5px 0; color: #28a745;">📏 거리 계산 결과</h5>'; 
                      
                     blastingMarkers.forEach((blastingMarker, bIndex) => { 
                         const blastingData = blastingMarker.blastingData; 
                          
                         measurementMarkers.forEach((measurementMarker, mIndex) => { 
                             const measurementData = measurementMarker.measurementData; 
                              
                             // Turf.js를 사용한 수평 거리 계산 
                             const horizontalDistance = turf.distance( 
                                 turf.point([blastingData.latlng.lng, blastingData.latlng.lat]), 
                                 turf.point([measurementData.latlng.lng, measurementData.latlng.lat]), 
                                 { units: 'meters' } 
                             ); 
                              
                             // 실이격거리 계산 (피타고라스 정리) 
                             const verticalDistance = blastingData.depth; 
                             const threeDDistance = Math.sqrt(horizontalDistance * horizontalDistance + verticalDistance * verticalDistance); 
                              
                             infoHTML += ` 
                                 <div style="padding: 8px; margin: 5px 0; background: #f8fff8; border-radius: 4px; border-left: 3px solid #28a745;"> 
                                     <div style="font-weight: bold; color: #333;">발파 ${bIndex + 1} ↔ 계측 ${mIndex + 1}</div> 
                                     <div style="font-size: 11px; color: #666;">수평 거리: ${horizontalDistance.toFixed(2)}m</div> 
                                     <div style="font-size: 11px; color: #666;">실이격거리: ${threeDDistance.toFixed(2)}m</div> 
                                     <div style="font-size: 11px; color: #666;">깊이: ${verticalDistance}m</div> 
                                 </div> 
                             `; 
                         }); 
                     }); 
                 } 
                  
                 // 마커가 하나도 없는 경우 
                 if (locationMarkers.length === 0 && blastingMarkers.length === 0 && measurementMarkers.length === 0) { 
                     infoHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 10px;">지도에서 위치를 추가하면 여기에 표시됩니다.</div>'; 
                 } 
                  
                 locationInfo.innerHTML = infoHTML; 
                  
             } catch (error) { 
                 console.error('정보 업데이트 중 오류:', error); 
             } 
         } 
          
         // 팝업에 마커 참조 추가 
         map.on('popupopen', function(e) { 
             if (e.popup && e.popup.getContent) { 
                 const content = e.popup.getContent(); 
                 if (content && content.includes('removeLocationMarker')) { 
                     e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target; 
                 } else if (content && content.includes('removeBlastingMarker')) { 
                     e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target; 
                 } else if (content && content.includes('removeMeasurementMarker')) { 
                     e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target; 
                 } 
             } 
         }); 

         // --- 2. DXF 렌더링 로직 (대폭 개선) --- 
         // GeoJSON 파일 로드 
         const geojsonInput = document.getElementById('geojson-input'); 
         geojsonInput.addEventListener('change', function(event) { 
             const file = event.target.files[0]; 
             if (!file) return; 

             const reader = new FileReader(); 
             reader.onload = function(e) { 
                 try { 
                     const geojsonData = JSON.parse(e.target.result); 
                     routeData = geojsonData; 
                      
                     // 기존 노선 레이어 제거 
                     if (routeLayer) { 
                         map.removeLayer(routeLayer); 
                     } 
                      
                     // 좌표계 변환을 위한 함수 
                     function transformCoordinates(feature) { 
                         if (feature.geometry && feature.geometry.coordinates) { 
                             if (feature.geometry.type === 'LineString') { 
                                 feature.geometry.coordinates = feature.geometry.coordinates.map(coord => { 
                                     // EPSG:5186 → WGS84 변환 
                                     const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord); 
                                     return [lng, lat]; 
                                 }); 
                             } else if (feature.geometry.type === 'Point') { 
                                 const coord = feature.geometry.coordinates; 
                                 const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord); 
                                 feature.geometry.coordinates = [lng, lat]; 
                             } 
                         } 
                         return feature; 
                     } 
                      
                     // 모든 피처에 대해 좌표계 변환 적용 
                     const transformedData = { 
                         ...geojsonData, 
                         features: geojsonData.features.map(transformCoordinates) 
                     }; 
                      
                     // 새로운 노선 레이어 추가 (변환된 좌표 사용) 
                     routeLayer = L.geoJSON(transformedData, { 
                         style: { 
                             color: '#ff6b35', 
                             weight: 3, 
                             opacity: 0.8 
                         } 
                     }).addTo(map); 
                      
                     // 노선에 맞춰 지도 뷰 조정 
                     if (geojsonData.features && geojsonData.features.length > 0) { 
                         map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }); 
                     } 
                      
                     document.getElementById('geojson-status').textContent = '노선 데이터 로드 완료!'; 
                     console.log('GeoJSON 노선 데이터 로드됨:', geojsonData); 
                      
                 } catch (error) { 
                     console.error('GeoJSON 파일 파싱 오류:', error); 
                     document.getElementById('geojson-status').textContent = '노선 파일 로드 실패.'; 
                 } 
             }; 
             reader.readAsText(file); 
         }); 

         const dxfInput = document.getElementById('dxf-input'); 
         dxfInput.addEventListener('change', function(event) { 
             const file = event.target.files[0]; 
             if (!file) return; 

             const reader = new FileReader(); 
             reader.onload = async function(e) { 
                 const statusEl = document.getElementById('status'); 
                 statusEl.textContent = '파일 처리 중...'; 
                  
                 // 기존 레이어 초기화 
                 dxfLayerGroup.clearLayers(); 
                 layerGroups.clear(); 
                 document.getElementById('layer-control').innerHTML = ''; 

                 try { 
                     // 먼저 새로운 DXF 파서 시도 
                     let CadData; 
                     if (typeof DXF !== 'undefined' && DXF.Helper) { 
                         try { 
                             const helper = new DXF.Helper(e.target.result); 
                             CadData = helper.getCadData(); 
                             console.log('새로운 DXF 파서로 성공:', CadData); 
                         } catch (newParserError) { 
                             console.log('새로운 파서 실패, 기존 파서 시도:', newParserError); 
                             throw newParserError; // 기존 파서로 넘어가기 위해 에러 발생 
                         } 
                     } else { 
                         throw new Error('DXF.Helper를 찾을 수 없습니다'); 
                     } 

                     if (!CadData.entities || CadData.entities.length === 0) { 
                         statusEl.textContent = '도형 정보를 찾을 수 없습니다.'; 
                         return; 
                     } 

                     // DXF 파일 구조 상세 분석 (새로운 파서) 
                     console.log('새로운 파서 - DXF 헤더 정보:', CadData.header); 
                     console.log('새로운 파서 - DXF 테이블 정보:', CadData.tables); 
                     console.log('새로운 파서 - DXF 블록 정보:', CadData.blocks); 
                      
                     // 모든 레이어 정보 수집 (새로운 파서) 
                     const allLayers = new Set(); 
                     CadData.entities.forEach(entity => { 
                         if (entity.layer) allLayers.add(entity.layer); 
                     }); 
                     console.log('새로운 파서 - 발견된 모든 레이어:', Array.from(allLayers)); 

                     // 좌표계 자동 감지 
                     const firstPoint = findFirstPoint(CadData.entities); 
                     const detectedEPSG = detectCoordinateSystem(firstPoint); 
                     statusEl.textContent = `좌표계 감지: EPSG:${detectedEPSG}. 도형 렌더링 중...`; 

                     // 각 도형(entity)을 지도에 그리기 
                     const allLatLngs = []; 
                     console.log('총 엔티티 수:', CadData.entities.length); 
                      
                     for (const entity of CadData.entities) { 
                         console.log('엔티티 타입:', entity.type, '레이어:', entity.layer); 
                          
                         const geometry = entityToLatLngs(entity, detectedEPSG); 
                         if (geometry.latlngs.length > 0) { 
                             const layerName = entity.layer || '0'; 
                             const style = getStyleForEntity(entity, CadData.tables ? CadData.tables.layers : null); 
                              
                             const layerGroup = getOrCreateLayerGroup(layerName, style.color); 
                              
                             if(geometry.type === 'polyline') { 
                                 L.polyline(geometry.latlngs, style).addTo(layerGroup); 
                             } else if(geometry.type === 'circle') { 
                                 L.circle(geometry.latlngs[0], { ...style, radius: geometry.radius }).addTo(layerGroup); 
                             } else if(geometry.type === 'hatch') { 
                                 // HATCH 엔티티를 폴리곤으로 렌더링 
                                 L.polygon(geometry.latlngs, { 
                                     fillColor: '#FFFF00', 
                                     color: '#FFD700', 
                                     weight: 2, 
                                     opacity: 0.3, 
                                     fillOpacity: 0.1 
                                 }).addTo(layerGroup); 
                             } else if(geometry.type === 'text') { 
                                 // 텍스트 객체 렌더링 
                                 const textContent = entity.text || entity.textString || 'TEXT'; 
                                  
                                 // 텍스트 위치에 직접 HTML 요소 추가 
                                 const textDiv = L.divIcon({ 
                                     className: 'text-marker', 
                                     html: `<div style="color: black; padding: 2px 6px; font-size: 12px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-weight: bold;">${textContent}</div>`, 
                                     iconSize: [0, 0], 
                                     iconAnchor: [0, 0] 
                                 }); 
                                  
                                 const textMarker = L.marker(geometry.latlngs[0], { 
                                     icon: textDiv, 
                                     interactive: true 
                                 }).addTo(layerGroup); 
                                  
                                 // 텍스트 팝업 추가 
                                 textMarker.bindPopup(` 
                                     <div style="min-width: 150px;"> 
                                         <strong>텍스트:</strong> ${textContent}<br> 
                                         <strong>레이어:</strong> ${layerName}<br> 
                                         <strong>좌표:</strong> ${geometry.latlngs[0][0].toFixed(6)}, ${geometry.latlngs[0][1].toFixed(6)} 
                                     </div> 
                                 `); 
                                  
                                 console.log('새로운 파서 - 텍스트 렌더링 성공:', textContent, '레이어:', layerName, '좌표:', geometry.latlngs[0]); 
                             } else if(geometry.type === 'point') { 
                                 // 점 객체 렌더링 
                                 L.circleMarker(geometry.latlngs[0], { 
                                     radius: 3, 
                                     fillColor: '#ff0000', 
                                     color: '#000', 
                                     weight: 1, 
                                     opacity: 1, 
                                     fillOpacity: 0.8 
                                 }).addTo(layerGroup); 
                             } 
                             allLatLngs.push(...geometry.latlngs); 
                         } else { 
                             console.log('변환 실패한 엔티티:', entity.type, entity); 
                         } 
                     } 

                     if (allLatLngs.length > 0) { 
                         map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] }); 
                         statusEl.textContent = `${CadData.entities.length}개 도형 로드 완료!`; 
                     } else { 
                         statusEl.textContent = '유효한 도형을 변환하지 못했습니다.'; 
                     } 

                 } catch (err) { 
                     console.log('새로운 파서 실패, 기존 파서로 시도:', err); 
                      
                     // 기존 파서로 재시도 
                     try { 
                         const parser = new DxfParser(); 
                         const dxf = parser.parseSync(e.target.result); 
                         console.log('기존 파서로 성공:', dxf); 
                          
                         // DXF 파일 구조 상세 분석 
                         console.log('DXF 헤더 정보:', dxf.header); 
                         console.log('DXF 테이블 정보:', dxf.tables); 
                         console.log('DXF 블록 정보:', dxf.blocks); 
                          
                         if (!dxf.entities || dxf.entities.length === 0) { 
                             statusEl.textContent = '도형 정보를 찾을 수 없습니다.'; 
                             return; 
                         } 
                          
                         // 모든 레이어 정보 수집 
                         const allLayers = new Set(); 
                         dxf.entities.forEach(entity => { 
                             if (entity.layer) allLayers.add(entity.layer); 
                         }); 
                         console.log('발견된 모든 레이어:', Array.from(allLayers)); 
                          
                         // 좌표계 자동 감지 
                         const firstPoint = findFirstPointLegacy(dxf.entities); 
                         const detectedEPSG = detectCoordinateSystem(firstPoint); 
                         statusEl.textContent = `좌표계 감지: EPSG:${detectedEPSG}. 도형 렌더링 중...`; 

                         // 각 도형을 지도에 그리기 
                         const allLatLngs = []; 
                         console.log('기존 파서 - 총 엔티티 수:', dxf.entities.length); 
                          
                         for (const entity of dxf.entities) { 
                             console.log('기존 파서 - 엔티티 타입:', entity.type, '레이어:', entity.layer); 
                              
                             const geometry = entityToLatLngsLegacy(entity, detectedEPSG); 
                             if (geometry.latlngs.length > 0) { 
                                 const layerName = entity.layer || '0'; 
                                 const style = getStyleForEntityLegacy(entity); 
                                  
                                 const layerGroup = getOrCreateLayerGroup(layerName, style.color); 
                                  
                                 if(geometry.type === 'polyline') { 
                                     L.polyline(geometry.latlngs, style).addTo(layerGroup); 
                                 } else if(geometry.type === 'circle') { 
                                     L.circle(geometry.latlngs[0], { ...style, radius: geometry.radius }).addTo(layerGroup); 
                                 } else if(geometry.type === 'hatch') { 
                                     // HATCH 엔티티를 폴리곤으로 렌더링 (기존 파서용) 
                                     L.polygon(geometry.latlngs, { 
                                         fillColor: '#FFFF00', 
                                         color: '#FFD700', 
                                         weight: 2, 
                                         opacity: 0.3, 
                                         fillOpacity: 0.1 
                                     }).addTo(layerGroup); 
                                 } else if(geometry.type === 'text') { 
                                 // 텍스트 객체 렌더링 (기존 파서용) 
                                 const textContent = entity.text || entity.textString || 'TEXT'; 
                                  
                                 // 텍스트 위치에 직접 HTML 요소 추가 
                                 const textDiv = L.divIcon({ 
                                     className: 'text-marker', 
                                     html: `<div style="color: black; padding: 2px 6px; font-size: 12px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-weight: bold;">${textContent}</div>`, 
                                     iconSize: [0, 0], 
                                     iconAnchor: [0, 0] 
                                 }); 
                                  
                                 const textMarker = L.marker(geometry.latlngs[0], { 
                                     icon: textDiv, 
                                     interactive: true 
                                 }).addTo(layerGroup); 
                                  
                                 // 텍스트 팝업 추가 
                                 textMarker.bindPopup(` 
                                     <div style="min-width: 150px;"> 
                                         <strong>텍스트:</strong> ${textContent}<br> 
                                         <strong>레이어:</strong> ${layerName}<br> 
                                         <strong>좌표:</strong> ${geometry.latlngs[0][0].toFixed(6)}, ${geometry.latlngs[0][1].toFixed(6)} 
                                     </div> 
                                 `); 
                                  
                                 console.log('텍스트 렌더링 성공:', textContent, '레이어:', layerName, '좌표:', geometry.latlngs[0]); 
                             } else if(geometry.type === 'point') { 
                                     // 점 객체 렌더링 (기존 파서용) 
                                     L.circleMarker(geometry.latlngs[0], { 
                                         radius: 3, 
                                         fillColor: '#ff0000', 
                                         color: '#000', 
                                         weight: 1, 
                                         opacity: 1, 
                                         fillOpacity: 0.8 
                                     }).addTo(layerGroup); 
                                 } 
                                 allLatLngs.push(...geometry.latlngs); 
                             } else { 
                                 console.log('기존 파서 - 변환 실패한 엔티티:', entity.type, entity); 
                             } 
                         } 

                         if (allLatLngs.length > 0) { 
                             map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] }); 
                             statusEl.textContent = `${dxf.entities.length}개 도형 로드 완료! (기존 파서)`; 
                         } else { 
                             statusEl.textContent = '유효한 도형을 변환하지 못했습니다.'; 
                         } 
                          
                     } catch (legacyError) { 
                         console.error('모든 DXF 파서 실패:', legacyError); 
                         statusEl.textContent = 'DXF 파일 처리 실패. 콘솔을 확인하세요.'; 
                     } 
                 } 
             }; 
             reader.readAsText(file, 'UTF-8'); 
         }); 

         // --- 3. 헬퍼 함수들 --- 
   
          function findFirstPoint(entities) { 
              for(const entity of entities) { 
                  if(entity.vertices && entity.vertices.length > 0) return entity.vertices[0]; 
                  if(entity.startPoint) return entity.startPoint; 
                  if(entity.center) return entity.center; 
              } 
              return null; 
          } 
           
          // 기존 파서용 헬퍼 함수들 
          function findFirstPointLegacy(entities) { 
              for(const entity of entities) { 
                  if(entity.vertices && entity.vertices.length > 0) return entity.vertices[0]; 
                  if(entity.startPoint) return entity.startPoint; 
                  if(entity.center) return entity.center; 
              } 
              return null; 
          } 
   
          function detectCoordinateSystem(point) { 
              if (!point) return "5186"; // 점이 없으면 기본값 반환 
               
              console.log('좌표계 감지 - 입력 좌표:', point); 
               
              // 더 많은 한국 좌표계 지원 
              const epsgCodes = ["5186", "5179", "5181", "5187", "5188", "5189", "5190", "5191", "5192", "5193", "5194", "5195", "5196", "5197", "5198", "5199"]; 
               
              for (const code of epsgCodes) { 
                  try { 
                      const [lon, lat] = proj4(`EPSG:${code}`, "EPSG:4326", [point.x, point.y]); 
                      console.log(`EPSG:${code} 변환 결과:`, lon, lat); 
                       
                      // 한국 영역 내 좌표인지 확인 (더 넓은 범위) 
                      if (lat >= 30 && lat <= 45 && lon >= 120 && lon <= 140) { 
                          console.log(`좌표계 감지 성공: EPSG:${code}`); 
                          return code; 
                      } 
                  } catch (e) { 
                      console.log(`EPSG:${code} 변환 실패:`, e.message); 
                  } 
              } 
               
              console.log('좌표계 감지 실패, 기본값 EPSG:5186 사용'); 
              return "5186"; // 감지 실패 시 기본값 
          } 
   
          function getOrCreateLayerGroup(layerName, color) { 
              if (!layerGroups.has(layerName)) { 
                  const group = L.layerGroup(); 
                  layerGroups.set(layerName, group); 
   
                  // 레이어 컨트롤 UI 추가 
                  const controlEl = document.getElementById('layer-control'); 
                  const div = document.createElement('div'); 
                  div.className = 'layer-item'; // 새로운 클래스 추가 
                  div.innerHTML = ` 
                      <input type="checkbox" id="layer-${layerName}" checked> 
                      <label for="layer-${layerName}" style="color:${color};">${layerName}</label> 
                      <input type="range" class="layer-opacity" min="0" max="1" step="0.1" value="1" onchange="setLayerOpacity(this.id.replace('layer-', ''), this.value)"> 
                  `; 
                  controlEl.appendChild(div); 
   
                  div.querySelector('input[type="checkbox"]').addEventListener('change', function() { 
                      if (this.checked) { 
                          group.addTo(dxfLayerGroup); 
                      } else { 
                          dxfLayerGroup.removeLayer(group); 
                      } 
                  }); 
                   
                  div.querySelector('.layer-opacity').addEventListener('input', function() { 
                      setLayerOpacity(layerName, this.value); 
                  }); 
                   
                  // 초기 상태로 레이어 추가 
                  group.addTo(dxfLayerGroup); 
              } 
              return layerGroups.get(layerName); 
          } 
           
          function getStyleForEntity(entity, layerTable) { 
              const layerName = entity.layer || '0'; 
              const layerInfo = layerTable ? layerTable[layerName] : null; 
              let color = '#FFFF00'; // 기본색: 노란색 
   
              if (entity.colorNumber) { 
                   color = DXF.ACAD_COLOR_PALETTE[entity.colorNumber] ? '#' + DXF.ACAD_COLOR_PALETTE[entity.colorNumber].toString(16).padStart(6, '0') : color; 
              } else if (layerInfo && layerInfo.colorNumber) { 
                   color = DXF.ACAD_COLOR_PALETTE[layerInfo.colorNumber] ? '#' + DXF.ACAD_COLOR_PALETTE[layerInfo.colorNumber].toString(16).padStart(6, '0') : color; 
              } 
               
              return { color: color, weight: 1, opacity: 0.95 }; 
          } 
           
          // 기존 파서용 스타일 함수 
          function getStyleForEntityLegacy(entity) { 
              const layerName = entity.layer || '0'; 
              let color = '#FFFF00'; // 기본색: 노란색 
               
              // 레이어별 색상 매핑 
              const layerColors = { 
                  '0': '#FFFF00', 'WALL': '#FFFF00', 'DOOR': '#00FF00', 'WINDOW': '#0000FF', 
                  'DIMENSION': '#FFFF00', 'TEXT': '#FF00FF', 'HATCH': '#00FFFF', 'CENTER': '#FF8000', 
                  'HIDDEN': '#808080', 'BORDER': '#FF0000', 'UTILITY': '#008000', 'EQUIPMENT': '#800000', 
                  'ANNOTATION': '#000080', 'ROAD': '#FFFF00', 'BUILDING': '#FFFF00', 'STRUCTURE': '#FF0000', 
                  'PIPE': '#00FFFF', 'ELECTRICAL': '#FF00FF', 'MECHANICAL': '#FF8000' 
              }; 
               
              if (layerColors[layerName]) { 
                  color = layerColors[layerName]; 
              } 
               
              return { color: color, weight: 0.8, opacity: 0.95 }; 
          } 
   
          function entityToLatLngs(entity, epsg) { 
              let latlngs = [], type = 'polyline', radius = 0; 
              const transform = (p) => { 
                  if(!p || typeof p.x === 'undefined' || typeof p.y === 'undefined') return null; 
                  const [lon, lat] = proj4(`EPSG:${epsg}`, "EPSG:4326", [p.x, p.y]); 
                  return [lat, lon]; 
              }; 
   
              switch (entity.type) { 
                  case 'LINE': 
                      latlngs = [transform(entity.startPoint), transform(entity.endPoint)].filter(p => p); 
                      break; 
                  case 'LWPOLYLINE': 
                  case 'POLYLINE': 
                      latlngs = entity.vertices.map(transform).filter(p => p); 
                      break; 
                  case 'CIRCLE': 
                      const centerLatLng = transform(entity.center); 
                      if(centerLatLng) { 
                          latlngs.push(centerLatLng); 
                          // 원의 반지름을 지도 단위(미터)로 근사 계산 
                          const edgePoint = { x: entity.center.x + entity.radius, y: entity.center.y }; 
                          const edgeLatLng = transform(edgePoint); 
                          radius = L.latLng(centerLatLng).distanceTo(L.latLng(edgeLatLng)); 
                          type = 'circle'; 
                      } 
                      break; 
                  case 'ARC': 
                      // ARC를 Polyline으로 근사화 (10개 점 사용) 
                      const arcPoints = []; 
                      const startAngle = entity.startAngle * Math.PI / 180; 
                      const endAngle = entity.endAngle * Math.PI / 180; 
                      const angleStep = (endAngle - startAngle) / 10; 
                      for (let i = 0; i <= 10; i++) { 
                          const angle = startAngle + i * angleStep; 
                          arcPoints.push({ 
                              x: entity.center.x + entity.radius * Math.cos(angle), 
                              y: entity.center.y + entity.radius * Math.sin(angle) 
                          }); 
                      } 
                      latlngs = arcPoints.map(transform).filter(p => p); 
                      break; 
                  // 용지도 관련 추가 엔티티들 
                  case 'TEXT': 
                  case 'MTEXT': 
                      if (entity.startPoint) { 
                          latlngs = [transform(entity.startPoint)]; 
                          type = 'text'; 
                      } 
                      break; 
                  case 'DIMENSION': 
                      if (entity.definitionPoint) { 
                          latlngs = [transform(entity.definitionPoint)]; 
                          type = 'dimension'; 
                      } 
                      break; 
                  case 'HATCH': 
                      if (entity.boundaryPaths && entity.boundaryPaths.length > 0) { 
                          // HATCH의 경계선을 Polyline으로 변환 
                          for (const path of entity.boundaryPaths) { 
                              if (path.edges) { 
                                  for (const edge of path.edges) { 
                                      if (edge.type === 'LINE') { 
                                          latlngs.push(transform(edge.startPoint), transform(edge.endPoint)); 
                                      } 
                                  } 
                              } 
                          } 
                      } 
                      break; 
                  case 'INSERT': 
                      if (entity.insertionPoint) { 
                          latlngs = [transform(entity.insertionPoint)]; 
                          type = 'insert'; 
                      } 
                      break; 
                  case 'POINT': 
                      if (entity.position) { 
                          latlngs = [transform(entity.position)]; 
                          type = 'point'; 
                      } 
                      break; 
                  case 'SPLINE': 
                      if (entity.controlPoints && entity.controlPoints.length > 0) { 
                          // SPLINE을 근사화하여 Polyline으로 변환 
                          latlngs = entity.controlPoints.map(transform).filter(p => p); 
                          type = 'spline'; 
                      } 
                      break; 
                  case 'ELLIPSE': 
                      if (entity.center) { 
                          const centerLatLng = transform(entity.center); 
                          if (centerLatLng) { 
                              latlngs.push(centerLatLng); 
                              // 타원을 원으로 근사화 
                              const majorAxis = entity.majorAxis || { x: 1, y: 0 }; 
                              const majorPoint = {  
                                  x: entity.center.x + majorAxis.x,  
                                  y: entity.center.y + majorAxis.y  
                              }; 
                              const majorLatLng = transform(majorPoint); 
                              if (majorLatLng) { 
                                  radius = L.latLng(centerLatLng).distanceTo(L.latLng(majorLatLng)); 
                                  type = 'ellipse'; 
                              } 
                          } 
                      } 
                      break; 
              } 
              return { latlngs, type, radius }; 
          } 
           
          // 기존 파서용 엔티티 변환 함수 
          function entityToLatLngsLegacy(entity, epsg) { 
              let latlngs = [], type = 'polyline', radius = 0; 
              const transform = (p) => { 
                  if(!p || typeof p.x === 'undefined' || typeof p.y === 'undefined') return null; 
                  const [lon, lat] = proj4(`EPSG:${epsg}`, "EPSG:4326", [p.x, p.y]); 
                  return [lat, lon]; 
              }; 
   
              switch (entity.type) { 
                  case 'LINE': 
                      if (entity.vertices && entity.vertices.length >= 2) { 
                          latlngs = [transform(entity.vertices[0]), transform(entity.vertices[1])].filter(p => p); 
                      } 
                      break; 
                  case 'LWPOLYLINE': 
                  case 'POLYLINE': 
                      if (entity.vertices && entity.vertices.length >= 2) { 
                          latlngs = entity.vertices.map(transform).filter(p => p); 
                      } 
                      break; 
                  case 'CIRCLE': 
                      if (entity.center) { 
                          const centerLatLng = transform(entity.center); 
                          if(centerLatLng) { 
                              latlngs.push(centerLatLng); 
                              // 원의 반지름을 지도 단위(미터)로 근사 계산 
                              const edgePoint = { x: entity.center.x + entity.radius, y: entity.center.y }; 
                              const edgeLatLng = transform(edgePoint); 
                              if (edgeLatLng) { 
                                  radius = L.latLng(centerLatLng).distanceTo(L.latLng(edgeLatLng)); 
                                  type = 'circle'; 
                              } 
                          } 
                      } 
                      break; 
                  case 'ARC': 
                      if (entity.center && entity.radius && entity.startAngle !== undefined && entity.endAngle !== undefined) { 
                          // ARC를 Polyline으로 근사화 (10개 점 사용) 
                          const arcPoints = []; 
                          const startAngle = entity.startAngle * Math.PI / 180; 
                          const endAngle = entity.endAngle * Math.PI / 180; 
                          const angleStep = (endAngle - startAngle) / 10; 
                          for (let i = 0; i <= 10; i++) { 
                              const angle = startAngle + i * angleStep; 
                              arcPoints.push({ 
                                  x: entity.center.x + entity.radius * Math.cos(angle), 
                                  y: entity.center.y + entity.radius * Math.sin(angle) 
                              }); 
                          } 
                          latlngs = arcPoints.map(transform).filter(p => p); 
                      } 
                      break; 
                  // 용지도 관련 추가 엔티티들 (기존 파서용) 
                  case 'TEXT': 
                  case 'MTEXT': 
                      if (entity.startPoint) { 
                          latlngs = [transform(entity.startPoint)]; 
                          type = 'text'; 
                      } 
                      break; 
                  case 'DIMENSION': 
                      if (entity.definitionPoint) { 
                          latlngs = [transform(entity.definitionPoint)]; 
                          type = 'dimension'; 
                      } 
                      break; 
                  case 'HATCH': 
                      if (entity.boundaryPaths && entity.boundaryPaths.length > 0) { 
                          // HATCH의 경계선을 Polyline으로 변환하고 면적 채우기 
                          for (const path of entity.boundaryPaths) { 
                              if (path.edges) { 
                                  const boundaryPoints = []; 
                                  for (const edge of path.edges) { 
                                      if (edge.type === 'LINE') { 
                                          const startPoint = transform(edge.startPoint); 
                                          const endPoint = transform(edge.endPoint); 
                                          if (startPoint && endPoint) { 
                                              boundaryPoints.push(startPoint, endPoint); 
                                          } 
                                      } 
                                  } 
                                  if (boundaryPoints.length >= 3) { 
                                      // 면적 채우기를 위한 폴리곤 생성 
                                      latlngs = boundaryPoints; 
                                      type = 'hatch'; 
                                  } 
                              } 
                          } 
                      } 
                      break; 
                  case 'INSERT': 
                      if (entity.insertionPoint) { 
                          latlngs = [transform(entity.insertionPoint)]; 
                          type = 'insert'; 
                      } 
                      break; 
                  case 'POINT': 
                      if (entity.position) { 
                          latlngs = [transform(entity.position)]; 
                          type = 'point'; 
                      } 
                      break; 
                  case 'SPLINE': 
                      if (entity.controlPoints && entity.controlPoints.length > 0) { 
                          // SPLINE을 근사화하여 Polyline으로 변환 
                          latlngs = entity.controlPoints.map(transform).filter(p => p); 
                          type = 'spline'; 
                      } 
                      break; 
                  case 'ELLIPSE': 
                      if (entity.center) { 
                          const centerLatLng = transform(entity.center); 
                          if (centerLatLng) { 
                              latlngs.push(centerLatLng); 
                              // 타원을 원으로 근사화 
                              const majorAxis = entity.majorAxis || { x: 1, y: 0 }; 
                              const majorPoint = {  
                                  x: entity.center.x + majorAxis.x,  
                                  y: entity.center.y + majorAxis.y  
                              }; 
                              const majorLatLng = transform(majorPoint); 
                              if (majorLatLng) { 
                                  radius = L.latLng(centerLatLng).distanceTo(L.latLng(majorPoint)); 
                                  type = 'ellipse'; 
                              } 
                          } 
                      } 
                      break; 
              } 
              return { latlngs, type, radius }; 
          } 

                  // STA. 값 계산 함수 (기준점 데이터 기반) 
         function calculateSTA(latlng, stationStart = 0) { 
             // 클릭한 위치를 EPSG:5186 좌표로 변환 
             const [clickX, clickY] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]); 
              
             let minDistance = Infinity; 
             let closestSTA = '계산 불가'; 
             let closestPoint = null; 
              
             // 모든 기준점과의 거리 계산하여 가장 가까운 지점 찾기 
             referencePoints.forEach(point => { 
                 const distance = Math.sqrt( 
                     Math.pow(clickX - point.x, 2) + Math.pow(clickY - point.y, 2) 
                 ); 
                  
                 if (distance < minDistance) { 
                     minDistance = distance; 
                     closestPoint = point; 
                 } 
             }); 
              
             if (closestPoint) { 
                 // 기준점에서 클릭한 지점까지의 실제 거리 계산 (미터 단위) 
                 const distanceFromReference = Math.sqrt( 
                     Math.pow(clickX - closestPoint.x, 2) + Math.pow(clickY - closestPoint.y, 2) 
                 ); 
                  
                 // 노선 진행 방향을 고려한 STA 값 계산 
                 // 기준점의 STA 값에 거리 차이를 더하거나 빼기 
                 let estimatedSTA = closestPoint.sta; 
                  
                 // 클릭한 지점이 기준점보다 노선 진행 방향에 있는지 판단 
                 // 간단한 방법: Y 좌표가 작을수록 노선 진행 방향 (25km → 27km) 
                 const isForward = clickY < closestPoint.y; 
                  
                 if (isForward) { 
                     // 노선 진행 방향: STA 값 증가 
                     estimatedSTA = closestPoint.sta + distanceFromReference; 
                 } else { 
                     // 노선 반대 방향: STA 값 감소 
                     estimatedSTA = closestPoint.sta - distanceFromReference; 
                 } 
                  
                 // STA. 형식으로 변환 (km+m 형식) 
                 const km = Math.floor(estimatedSTA / 1000); 
                 const m = Math.round(estimatedSTA % 1000); 
                 closestSTA = `STA. ${km}km${m.toString().padStart(3, '0')}`; 
                  
                 // 디버깅용 콘솔 출력 
                 console.log(`기준점: STA.${closestPoint.sta}m (${closestPoint.x}, ${closestPoint.y})`); 
                 console.log(`클릭위치: (${clickX.toFixed(3)}, ${clickY.toFixed(3)})`); 
                 console.log(`거리: ${distanceFromReference.toFixed(2)}m`); 
                 console.log(`방향: ${isForward ? '진행방향' : '반대방향'}`); 
                 console.log(`계산된 STA: ${estimatedSTA.toFixed(2)}m`); 
             } 
              
             return closestSTA; 
         } 
          
         // 레이어 투명도 설정 (개선된 버전) 
         function setLayerOpacity(layerName, opacity) { 
             const layerGroup = layerGroups.get(layerName); 
             if (layerGroup) { 
                 // 레이어 그룹 내의 모든 레이어에 투명도 적용 
                 layerGroup.eachLayer(function(layer) { 
                     if (layer.setStyle) { 
                         layer.setStyle({ opacity: opacity }); 
                     } 
                 }); 
             } 
         } 
          
         // 발파위치 데이터를 Streamlit으로 전송하는 함수 
         function sendBlastingLocationsToStreamlit() { 
             try { 
                 // 현재 지도에 있는 모든 발파 마커 데이터 수집 
                 const blastingMarkers = window.blastingMarkers || []; 
                 const locations = []; 
                  
                 blastingMarkers.forEach(marker => { 
                     if (marker.blastingData) { 
                         locations.push({ 
                             id: marker.blastingData.id, 
                             sta: marker.blastingData.sta, 
                             coordinates: marker.blastingData.coordinates, 
                             depth: marker.blastingData.depth, 
                             description: marker.blastingData.description, 
                             timestamp: new Date().toISOString(), 
                             source: 'map' 
                         }); 
                     } 
                 }); 
                  
                 console.log('📤 Streamlit으로 전송할 발파위치 데이터:', locations); 
                  
                 // URL 파라미터로 전송 
                 const url = new URL(window.location); 
                 url.searchParams.set('blasting_data', JSON.stringify(locations)); 
                 window.history.replaceState({}, '', url); 
                  
                 // Streamlit 페이지 새로고침으로 데이터 전달 
                 setTimeout(() => { 
                     // 부모 창이 Streamlit인 경우 새로고침 
                     if (window.parent && window.parent !== window) { 
                         window.parent.location.reload(); 
                     } else { 
                         window.location.reload(); 
                     } 
                 }, 500); 
                  
                 return locations; 
             } catch (error) { 
                 console.error('❌ 발파위치 데이터 전송 중 오류:', error); 
                 return []; 
             } 
         } 
          
         // 발파위치 추가/삭제 시 자동 동기화 
         function syncBlastingLocations() { 
             setTimeout(() => { 
                 sendBlastingLocationsToStreamlit(); 
             }, 100); 
         } 
          
         // 기존 발파위치 추가 함수에 동기화 추가 
         const originalAddBlastingMarker = window.addBlastingMarker; 
         if (originalAddBlastingMarker) { 
             window.addBlastingMarker = async function(latlng) { 
                 const result = await originalAddBlastingMarker(latlng); 
                 syncBlastingLocations(); 
                 return result; 
             }; 
         } 
          
         // 발파위치 삭제 시에도 동기화 
         const originalRemoveBlastingMarker = window.removeBlastingMarker; 
         if (originalRemoveBlastingMarker) { 
             window.removeBlastingMarker = function(marker) { 
                 const result = originalRemoveBlastingMarker(marker); 
                 syncBlastingLocations(); 
                 return result; 
             }; 
         } 
          
         // 페이지 로드 시 초기 동기화 
         window.addEventListener('load', function() { 
             setTimeout(syncBlastingLocations, 1000); 
         }); 
          
         // 주기적 동기화 (5초마다) 
         setInterval(syncBlastingLocations, 5000); 
     </script> 
 </body> 
 </html>