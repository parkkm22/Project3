<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Leaflet | Advanced DXF Viewer</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        html, body, #map { margin: 0; height: 100%; width: 100%; overflow: hidden; }
        
        /* ì¢Œì¸¡ ë©”ì¸ ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .main-control-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            border-right: 2px solid #e0e0e0;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .main-control-panel h3 {
            margin: 0;
            padding: 20px 20px 15px 20px;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #007bff;
            background: #f8f9fa;
        }
        
        .control-section {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
        }
        
        .control-section h4 {
            margin: 0 0 12px 0;
            color: #007bff;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }
        
        .control-section h4 i {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .file-upload-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .file-upload-section input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 2px dashed #007bff;
            border-radius: 6px;
            background: white;
            font-size: 12px;
            cursor: pointer;
        }
        
        .file-upload-section input[type="file"]:hover {
            border-color: #0056b3;
            background: #f0f8ff;
        }
        
        #status {
            margin-top: 10px;
            padding: 8px 12px;
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            border-radius: 4px;
            font-size: 12px;
            color: #0056b3;
        }
        
        #layer-control {
            max-height: 300px;
            overflow-y: auto;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .layer-item:last-child {
            border-bottom: none;
        }
        
        .layer-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .layer-item label {
            flex: 1;
            font-size: 12px;
            color: #333;
            cursor: pointer;
        }
        
        .layer-opacity {
            width: 60px;
            height: 20px;
            margin-left: 10px;
        }
        
        /* ë„êµ¬ íŒ¨ë„ ìŠ¤íƒ€ì¼ */
        .tools-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            min-width: 180px;
        }
        
        .tools-panel h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 14px;
            text-align: center;
            font-weight: 600;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }
        
        .tool-button {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin: 8px 0;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #555;
        }
        
        .tool-button:hover {
            background: #007bff;
            color: white;
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }
        
        .tool-button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }
        
        .tool-button i {
            display: block;
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        /* ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #000;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .btn {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        /* íƒœê·¸ ê´€ë ¨ ìŠ¤íƒ€ì¼ */
        .tag-preview {
            transition: all 0.2s ease;
        }
        
        .tag-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* íƒœê·¸ê°€ ìˆëŠ” ë§ˆì»¤ ìŠ¤íƒ€ì¼ */
        .location-marker-with-tags {
            background: transparent !important;
            border: none !important;
        }
        
        .location-marker-with-tags .leaflet-marker-icon {
            background: transparent !important;
            border: none !important;
        }
    </style>
</head>
<body>
    <div id="map"></div>
 
     <div class="main-control-panel">
        <h3>GIS/CAD ë·°ì–´</h3>
        <div class="control-section">
            <h4>ğŸ“ DXF íŒŒì¼ ì—…ë¡œë“œ</h4>
            <div class="file-upload-section">
                <input type="file" id="dxf-input" accept=".dxf">
                <div id="status">íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.</div>
            </div>
        </div>
        <div class="control-section">
            <h4>ğŸ—ºï¸ GeoJSON ë…¸ì„  ë¡œë“œ</h4>
            <div class="file-upload-section">
                <input type="file" id="geojson-input" accept=".geojson">
                <div id="geojson-status">ë…¸ì„  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.</div>
            </div>
        </div>
        <div class="control-section">
            <h4>ğŸ—‚ï¸ ë ˆì´ì–´ ê´€ë¦¬</h4>
            <div id="layer-control">
                <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
                    DXF íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ë ˆì´ì–´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
                </div>
            </div>
        </div>
        <div class="control-section">
            <h4>ğŸ“ ìœ„ì¹˜ ì •ë³´</h4>
            <div id="location-info" style="font-size: 12px; color: #666;">
                ì§€ë„ì—ì„œ ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
            </div>
        </div>
        <div class="control-section">
            <h4>ğŸ’¥ ë°œíŒŒ ì •ë³´</h4>
            <div id="blasting-info" style="font-size: 12px; color: #666;">
                ë°œíŒŒ ìœ„ì¹˜ì™€ ê³„ì¸¡ ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
            </div>
        </div>
    </div>
     
     <!-- ë„êµ¬ íŒ¨ë„ -->
     <div class="tools-panel">
        <h4>ğŸ› ï¸ ë„êµ¬</h4>
        <button class="tool-button" id="add-location-btn">
            <i>ğŸ“</i>
            ìœ„ì¹˜ ì¶”ê°€
        </button>
        <button class="tool-button" id="add-blasting-btn">
            <i>ğŸ’¥</i>
            ë°œíŒŒ ìœ„ì¹˜
        </button>
        <button class="tool-button" id="add-measurement-btn">
            <i>ğŸ“Š</i>
            ê³„ì¸¡ ìœ„ì¹˜
        </button>
        <button class="tool-button" id="measure-distance-btn">
            <i>ğŸ“</i>
            ê±°ë¦¬ ê³„ì‚°
        </button>
        <button class="tool-button" id="clear-all-btn">
            <i>ğŸ—‘ï¸</i>
            ì „ì²´ ì‚­ì œ
        </button>
    </div>
    
    <!-- ìœ„ì¹˜ ì¶”ê°€ ëª¨ë‹¬ -->
    <div id="location-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ìœ„ì¹˜ ì •ë³´ ì¶”ê°€</span>
                <span class="close" id="close-location-modal">&times;</span>
            </div>
            <form id="location-form">
                <div class="form-group">
                    <label for="location-name">ìœ„ì¹˜ëª…</label>
                    <input type="text" id="location-name" name="location-name" placeholder="ìœ„ì¹˜ëª…ì„ ì…ë ¥í•˜ì„¸ìš”" required>
                </div>
                <div class="form-group">
                    <label for="location-description">ì„¤ëª…</label>
                    <textarea id="location-description" name="location-description" placeholder="ìœ„ì¹˜ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
                </div>
                <div class="form-group">
                    <label for="location-category">ì¹´í…Œê³ ë¦¬</label>
                    <input type="text" id="location-category" name="location-category" placeholder="ì¹´í…Œê³ ë¦¬ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ê±´ë¬¼, ì‹œì„¤ë¬¼, ê´€ì‹¬ì§€ì )">
                </div>
                <div class="form-group">
                    <label for="location-tags">íƒœê·¸</label>
                    <input type="text" id="location-tags" name="location-tags" placeholder="íƒœê·¸ë¥¼ ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ê±´ì„¤ì¤‘, ì¤‘ìš”, ì ê²€í•„ìš”)">
                    <div id="tags-preview" style="margin-top: 8px; min-height: 20px;"></div>
                </div>
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" class="btn btn-secondary" id="cancel-location">ì·¨ì†Œ</button>
                    <button type="submit" class="btn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ë°œíŒŒ ì •ë³´ ëª¨ë‹¬ -->
    <div id="blasting-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ë°œíŒŒ ì •ë³´ ì…ë ¥</span>
                <span class="close" id="close-blasting-modal">&times;</span>
            </div>
            <form id="blasting-form">
                <div class="form-group">
                    <label for="blasting-id">ë°œíŒŒ ID</label>
                    <input type="text" id="blasting-id" name="blasting-id" placeholder="ë°œíŒŒ ì‘ì—… IDë¥¼ ì…ë ¥í•˜ì„¸ìš”" required>
                </div>
                <div class="form-group">
                    <label>Station ê³„ì‚° ë°©ì‹</label>
                    <div style="background: #e7f3ff; padding: 8px; border-radius: 4px; border-left: 3px solid #007bff; font-size: 12px; color: #0056b3;">
                        âœ… ê¸°ì¤€ì  ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.<br>
                        ğŸ“ ì§€ë„ì—ì„œ í´ë¦­í•˜ë©´ ì •í™•í•œ STA ê°’ì´ ìë™ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
                    </div>
                </div>
                <div class="form-group">
                    <label for="blasting-sta">ë°œíŒŒìœ„ì¹˜(Sta.)</label>
                    <input type="text" id="blasting-sta" name="blasting-sta" placeholder="ìë™ ê³„ì‚°ë¨" readonly>
                </div>
                <div class="form-group">
                    <label for="blasting-coordinates">ë°œíŒŒì¢Œí‘œ(X,Y) - EPSG:5186</label>
                    <input type="text" id="blasting-coordinates" name="blasting-coordinates" placeholder="ìë™ ê³„ì‚°ë¨" readonly>
                </div>
                <div class="form-group">
                    <label for="blasting-depth">ê¹Šì´(m)</label>
                    <input type="number" id="blasting-depth" name="blasting-depth" placeholder="ë°œíŒŒ ê¹Šì´ë¥¼ ì…ë ¥í•˜ì„¸ìš”" step="0.1" min="0" required>
                </div>
                <div class="form-group">
                    <label for="blasting-description">ì„¤ëª…</label>
                    <textarea id="blasting-description" name="blasting-description" placeholder="ë°œíŒŒ ì‘ì—…ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
                </div>
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" class="btn btn-secondary" id="cancel-blasting">ì·¨ì†Œ</button>
                    <button type="submit" class="btn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ê³„ì¸¡ ì •ë³´ ëª¨ë‹¬ -->
    <div id="measurement-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ê³„ì¸¡ ì •ë³´ ì…ë ¥</span>
                <span class="close" id="close-measurement-modal">&times;</span>
            </div>
            <form id="measurement-form">
                <div class="form-group">
                    <label for="measurement-sta">ê³„ì¸¡ìœ„ì¹˜(Sta.)</label>
                    <input type="text" id="measurement-sta" name="measurement-sta" placeholder="ìë™ ê³„ì‚°ë¨" readonly>
                </div>
                <div class="form-group">
                    <label for="measurement-coordinates">ê³„ì¸¡ì¢Œí‘œ(X,Y) - EPSG:5186</label>
                    <input type="text" id="measurement-coordinates" name="measurement-coordinates" placeholder="ìë™ ê³„ì‚°ë¨" readonly>
                </div>
                <div class="form-group">
                    <label for="measurement-description">ì„¤ëª…</label>
                    <textarea id="measurement-description" name="measurement-description" placeholder="ê³„ì¸¡ ì‘ì—…ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
                </div>
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" class="btn btn-secondary" id="cancel-measurement">ì·¨ì†Œ</button>
                    <button type="submit" class="btn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>
 
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/proj4@2.11.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <!-- DXF íŒŒì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ -->
    <script src="https://unpkg.com/dxf@4.7.0/dist/dxf.js"></script>
    <!-- ë°±ì—…ìš© ê¸°ì¡´ íŒŒì„œ -->
    <script src="https://unpkg.com/dxf-parser@1.1.2/dist/dxf-parser.js"></script>

    <script>
        // --- 1. ì„¤ì • ë° ì´ˆê¸°í™” ---
        const VWORLD_API_KEY = "5B2CF3E9-3FA1-3D3D-8B82-B65B360AFAAE";
        const VWORLD_SATELLITE_URL = `https://api.vworld.kr/req/wmts/1.0.0/${VWORLD_API_KEY}/Satellite/{z}/{y}/{x}.jpeg`;
        
        // ê³ í•´ìƒë„ íƒ€ì¼ ì„œë¹„ìŠ¤ë“¤
        const GOOGLE_SATELLITE_URL = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';
        const ESRI_SATELLITE_URL = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
        const BING_SATELLITE_URL = 'https://ecn.t3.tiles.virtualearth.net/tiles/a{q}.jpeg?g=1';

        proj4.defs("EPSG:5186", "+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs");
        proj4.defs("EPSG:5179", "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +units=m +no_defs");

        const map = L.map('map', { center: [36.5, 127.5], zoom: 7, maxZoom: 25 });
        
        // ê¸°ë³¸ V-World ìœ„ì„± ì´ë¯¸ì§€ (ì¤Œ 0-19)
        const vworldLayer = L.tileLayer(VWORLD_SATELLITE_URL, { 
            attribution: 'V-World',
            maxZoom: 19,
            minZoom: 0
        });
        
        // ê³ í•´ìƒë„ Google ìœ„ì„± ì´ë¯¸ì§€ (ì¤Œ 19-25)
        const googleLayer = L.tileLayer(GOOGLE_SATELLITE_URL, {
            attribution: 'Google Satellite',
            maxZoom: 25,
            minZoom: 19
        });
        
        // ESRI ê³ í•´ìƒë„ ìœ„ì„± ì´ë¯¸ì§€ (ì¤Œ 19-25, ë°±ì—…ìš©)
        const esriLayer = L.tileLayer(ESRI_SATELLITE_URL, {
            attribution: 'ESRI World Imagery',
            maxZoom: 25,
            minZoom: 19
        });
        
        // ì´ˆê¸° ë ˆì´ì–´ ì¶”ê°€
        vworldLayer.addTo(map);
        
        // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ë ˆì´ì–´ ìë™ ì „í™˜ (ê°œì„ ëœ ë²„ì „)
        let currentBaseLayer = vworldLayer;
        
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            let targetLayer;
            
            if (currentZoom >= 19) {
                targetLayer = googleLayer;
            } else {
                targetLayer = vworldLayer;
            }
            
            // í˜„ì¬ ë² ì´ìŠ¤ ë ˆì´ì–´ì™€ ë‹¤ë¥¸ ê²½ìš°ì—ë§Œ ì „í™˜
            if (targetLayer !== currentBaseLayer) {
                // ê¸°ì¡´ ë² ì´ìŠ¤ ë ˆì´ì–´ ì œê±°
                if (map.hasLayer(currentBaseLayer)) {
                    map.removeLayer(currentBaseLayer);
                }
                
                // ìƒˆë¡œìš´ ë² ì´ìŠ¤ ë ˆì´ì–´ ì¶”ê°€
                targetLayer.addTo(map);
                currentBaseLayer = targetLayer;
                
                // DXF ë ˆì´ì–´ë¥¼ ë² ì´ìŠ¤ ë ˆì´ì–´ ìœ„ì— ë‹¤ì‹œ ì¶”ê°€
                addDXFLayerToMap();
                
                console.log(`ì¤Œ ë ˆë²¨ ${currentZoom}: ${targetLayer === googleLayer ? 'Google' : 'V-World'} ë ˆì´ì–´ë¡œ ì „í™˜`);
            }
        });
 
        const dxfLayerGroup = L.layerGroup().addTo(map);
        const layerGroups = new Map(); // ë ˆì´ì–´ë³„ ê·¸ë£¹ ê´€ë¦¬ë¥¼ ìœ„í•œ Map
        
        // ë ˆì´ì–´ ê·¸ë£¹ì„ ë² ì´ìŠ¤ ë ˆì´ì–´ ìœ„ì— ì¶”ê°€í•˜ê¸° ìœ„í•œ í•¨ìˆ˜
        function addDXFLayerToMap() {
            if (map.hasLayer(dxfLayerGroup)) {
                map.removeLayer(dxfLayerGroup);
            }
            map.addLayer(dxfLayerGroup);
        }
        
        // ë„êµ¬ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let isAddingLocation = false;
        let isMeasuringDistance = false;
        let isAddingBlasting = false;
        let isAddingMeasurement = false;
        let locationMarkers = [];
        let distanceMarkers = [];
        let distancePolylines = [];
        let currentDistancePoints = [];
        
        // ë°œíŒŒ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let blastingMarkers = [];
        let measurementMarkers = [];
        let routeData = null; // GeoJSON ë…¸ì„  ë°ì´í„°
        let routeLayer = null; // ë…¸ì„  ë ˆì´ì–´
        

        
        // ê¸°ì¤€ì  ë°ì´í„° (QGISì—ì„œ ìƒì„±ëœ ì •í™•í•œ ì¢Œí‘œ-STA ìŒ)
        const referencePoints = [
            { x: 191210.1879, y: 545380.3588, sta: 27135.5 },    // 27km135.5
            { x: 191786.3363, y: 544295.5358, sta: 25906.904 },  // 25km906.904
            { x: 191848.1417, y: 544171.445, sta: 25798.249 },   // 25km798.249
            { x: 191876.4512, y: 544101.7818, sta: 25693.038 },  // 25km693.038
            { x: 191942.2975, y: 543890.4457, sta: 25471.646 },  // 25km471.646
            { x: 191969.7389, y: 543767.1543, sta: 25345.090 },  // 25km345.090
            { x: 191970.5232, y: 543731.0956, sta: 25309.000 },  // 25km309
            { x: 191964.6604, y: 543682.5013, sta: 25260.000 },  // 25km260
            { x: 191959.9417, y: 543662.8322, sta: 25240.000 },  // 25km240
            { x: 191949.0639, y: 543630.6385, sta: 25205.769 },  // 25km205.769
            { x: 191929.2976, y: 543589.3926, sta: 25160.000 },  // 25km160
            { x: 191886.7836, y: 543521.6553, sta: 25080.000 },  // 25km080
            { x: 191842.3080, y: 543455.1577, sta: 25000.000 }   // 25km000
        ];
        
        // ê¸°ë³¸ ë…¸ì„  ë°ì´í„° ë¡œë“œ (í…ŒìŠ¤íŠ¸ìš©)
        fetch('./route.geojson')
            .then(response => response.json())
            .then(data => {
                // ì¢Œí‘œê³„ ë³€í™˜ì„ ìœ„í•œ í•¨ìˆ˜
                function transformCoordinates(feature) {
                    if (feature.geometry && feature.geometry.coordinates) {
                        if (feature.geometry.type === 'LineString') {
                            feature.geometry.coordinates = feature.geometry.coordinates.map(coord => {
                                // EPSG:5186 â†’ WGS84 ë³€í™˜
                                const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord);
                                return [lng, lat];
                            });
                        } else if (feature.geometry.type === 'Point') {
                            const coord = feature.geometry.coordinates;
                            const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord);
                            feature.geometry.coordinates = [lng, lat];
                        }
                    }
                    return feature;
                }
                
                // ëª¨ë“  í”¼ì²˜ì— ëŒ€í•´ ì¢Œí‘œê³„ ë³€í™˜ ì ìš©
                const transformedData = {
                    ...data,
                    features: data.features.map(transformCoordinates)
                };
                
                routeData = transformedData;
                console.log('ê¸°ë³¸ ë…¸ì„  ë°ì´í„° ë¡œë“œë¨ (ì¢Œí‘œê³„ ë³€í™˜ ì™„ë£Œ):', transformedData);
                
                // ë³€í™˜ëœ ë°ì´í„°ë¡œ ë…¸ì„  ë ˆì´ì–´ ìƒì„±
                routeLayer = L.geoJSON(transformedData, {
                    style: {
                        color: '#ff6b35',
                        weight: 3,
                        opacity: 0.8
                    }
                }).addTo(map);
                
                // ë…¸ì„ ì— ë§ì¶° ì§€ë„ ë·° ì¡°ì •
                if (transformedData.features && transformedData.features.length > 0) {
                    map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
                }
                
            })
            .catch(error => {
                console.log('ê¸°ë³¸ ë…¸ì„  ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨, íŒŒì¼ ì—…ë¡œë“œ í•„ìš”:', error);
            });
        
        // ë„êµ¬ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('add-location-btn').addEventListener('click', function() {
            toggleLocationMode();
        });
        
        document.getElementById('measure-distance-btn').addEventListener('click', function() {
            toggleDistanceMode();
        });
        
        document.getElementById('add-blasting-btn').addEventListener('click', function() {
            toggleBlastingMode();
        });
        
        document.getElementById('add-measurement-btn').addEventListener('click', function() {
            toggleMeasurementMode();
        });
        
        document.getElementById('clear-all-btn').addEventListener('click', function() {
            if (confirm('ëª¨ë“  ìœ„ì¹˜ ë§ˆì»¤ì™€ ê±°ë¦¬ ì¸¡ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                clearAllMarkers();
            }
        });
        
        // ëª¨ë‹¬ ê´€ë ¨ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('close-location-modal').addEventListener('click', function() {
            closeLocationModal();
        });
        
        document.getElementById('cancel-location').addEventListener('click', function() {
            closeLocationModal();
        });
        
        // ë°œíŒŒ ëª¨ë‹¬ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('close-blasting-modal').addEventListener('click', function() {
            closeBlastingModal();
        });
        
        document.getElementById('cancel-blasting').addEventListener('click', function() {
            closeBlastingModal();
        });
        
        // ê³„ì¸¡ ëª¨ë‹¬ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('close-measurement-modal').addEventListener('click', function() {
            closeMeasurementModal();
        });
        
        document.getElementById('cancel-measurement').addEventListener('click', function() {
            closeMeasurementModal();
        });
        

        
        // íƒœê·¸ ì…ë ¥ ì‹œ ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°
        document.getElementById('location-tags').addEventListener('input', function() {
            updateTagsPreview();
        });
        
        // íƒœê·¸ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updateTagsPreview() {
            const tagsInput = document.getElementById('location-tags');
            const tagsPreview = document.getElementById('tags-preview');
            const tags = tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            if (tags.length > 0) {
                const tagsHTML = tags.map(tag => 
                    `<span class="tag-preview" style="display: inline-block; background: #007bff; color: white; padding: 2px 8px; margin: 2px; border-radius: 12px; font-size: 11px;">${tag}</span>`
                ).join('');
                tagsPreview.innerHTML = tagsHTML;
            } else {
                tagsPreview.innerHTML = '';
            }
        }
        
        // ìœ„ì¹˜ ì¶”ê°€ ëª¨ë“œ í† ê¸€
        function toggleLocationMode() {
            if (isAddingLocation) {
                isAddingLocation = false;
                document.getElementById('add-location-btn').classList.remove('active');
                map.getContainer().style.cursor = '';
            } else {
                // ë‹¤ë¥¸ ëª¨ë“œ ë¹„í™œì„±í™”
                isMeasuringDistance = false;
                document.getElementById('measure-distance-btn').classList.remove('active');
                
                // ìœ„ì¹˜ ì¶”ê°€ ëª¨ë“œ í™œì„±í™”
                isAddingLocation = true;
                document.getElementById('add-location-btn').classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
            }
        }
        
        // ë°œíŒŒ ëª¨ë“œ í† ê¸€
        function toggleBlastingMode() {
            if (isAddingBlasting) {
                isAddingBlasting = false;
                document.getElementById('add-blasting-btn').classList.remove('active');
                map.getContainer().style.cursor = '';
            } else {
                // ë‹¤ë¥¸ ëª¨ë“œ ë¹„í™œì„±í™”
                isAddingLocation = false;
                isMeasuringDistance = false;
                isAddingMeasurement = false;
                document.getElementById('add-location-btn').classList.remove('active');
                document.getElementById('measure-distance-btn').classList.remove('active');
                document.getElementById('add-measurement-btn').classList.remove('active');
                
                // ë°œíŒŒ ëª¨ë“œ í™œì„±í™”
                isAddingBlasting = true;
                document.getElementById('add-blasting-btn').classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
            }
        }
        
        // ê³„ì¸¡ ëª¨ë“œ í† ê¸€
        function toggleMeasurementMode() {
            if (isAddingMeasurement) {
                isAddingMeasurement = false;
                document.getElementById('add-measurement-btn').classList.remove('active');
                map.getContainer().style.cursor = '';
            } else {
                // ë‹¤ë¥¸ ëª¨ë“œ ë¹„í™œì„±í™”
                isAddingLocation = false;
                isMeasuringDistance = false;
                isAddingBlasting = false;
                document.getElementById('add-location-btn').classList.remove('active');
                document.getElementById('measure-distance-btn').classList.remove('active');
                document.getElementById('add-blasting-btn').classList.remove('active');
                
                // ê³„ì¸¡ ëª¨ë“œ í™œì„±í™”
                isAddingMeasurement = true;
                document.getElementById('add-measurement-btn').classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
            }
        }
        
        // ê±°ë¦¬ ê³„ì‚° ëª¨ë“œ í† ê¸€
        function toggleDistanceMode() {
            if (isMeasuringDistance) {
                isMeasuringDistance = false;
                document.getElementById('measure-distance-btn').classList.remove('active');
                map.getContainer().style.cursor = '';
                finishDistanceMeasurement();
            } else {
                // ë‹¤ë¥¸ ëª¨ë“œ ë¹„í™œì„±í™”
                isAddingLocation = false;
                isAddingBlasting = false;
                isAddingMeasurement = false;
                document.getElementById('add-location-btn').classList.remove('active');
                document.getElementById('add-blasting-btn').classList.remove('active');
                document.getElementById('add-measurement-btn').classList.remove('active');
                
                // ê±°ë¦¬ ê³„ì‚° ëª¨ë“œ í™œì„±í™”
                isMeasuringDistance = true;
                document.getElementById('measure-distance-btn').classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
                startDistanceMeasurement();
            }
        }
        
        // ê±°ë¦¬ ê³„ì‚° ì‹œì‘
        function startDistanceMeasurement() {
            currentDistancePoints = [];
            map.on('click', onMapClickForDistance);
        }
        
        // ê±°ë¦¬ ê³„ì‚°ì„ ìœ„í•œ ì§€ë„ í´ë¦­ ì´ë²¤íŠ¸
        function onMapClickForDistance(e) {
            if (!isMeasuringDistance) return;
            
            const latlng = e.latlng;
            currentDistancePoints.push(latlng);
            
            // ë§ˆì»¤ ì¶”ê°€
            const marker = L.marker(latlng, {
                icon: L.divIcon({
                    className: 'distance-marker',
                    html: `<div style="background: #007bff; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">${currentDistancePoints.length}</div>`,
                    iconSize: [20, 20]
                })
            }).addTo(map);
            
            distanceMarkers.push(marker);
            
            // ì„  ê·¸ë¦¬ê¸°
            if (currentDistancePoints.length > 1) {
                const polyline = L.polyline([currentDistancePoints[currentDistancePoints.length - 2], latlng], {
                    color: '#007bff',
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);
                
                distancePolylines.push(polyline);
                
                // ê±°ë¦¬ í‘œì‹œ
                const distance = calculateDistance(currentDistancePoints[currentDistancePoints.length - 2], latlng);
                L.tooltip({
                    permanent: true,
                    direction: 'center'
                })
                .setContent(`${distance.toFixed(2)}m`)
                .setLatLng([(currentDistancePoints[currentDistancePoints.length - 2].lat + latlng.lat) / 2, (currentDistancePoints[currentDistancePoints.length - 2].lng + latlng.lng) / 2])
                .addTo(map);
            }
        }
        
        // ê±°ë¦¬ ê³„ì‚° ì™„ë£Œ
        function finishDistanceMeasurement() {
            map.off('click', onMapClickForDistance);
            
            if (currentDistancePoints.length > 1) {
                const totalDistance = calculateTotalDistance();
                alert(`ì´ ê±°ë¦¬: ${totalDistance.toFixed(2)}m`);
            }
        }
        
        // ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚° (ë¯¸í„°)
        function calculateDistance(point1, point2) {
            return L.latLng(point1.lat, point1.lng).distanceTo(L.latLng(point2.lat, point2.lng));
        }
        
        // ì´ ê±°ë¦¬ ê³„ì‚°
        function calculateTotalDistance() {
            let total = 0;
            for (let i = 1; i < currentDistancePoints.length; i++) {
                total += calculateDistance(currentDistancePoints[i-1], currentDistancePoints[i]);
            }
            return total;
        }
        
        // ìœ„ì¹˜ ì¶”ê°€ë¥¼ ìœ„í•œ ì§€ë„ í´ë¦­ ì´ë²¤íŠ¸
        map.on('click', function(e) {
            // ë§ˆì§€ë§‰ í´ë¦­ ìœ„ì¹˜ ì €ì¥ (Station ì‹œì‘ì  ë³€ê²½ ì‹œ STA. ì¬ê³„ì‚°ìš©)
            window.lastClickedLatLng = e.latlng;
            
            if (isAddingLocation) {
                showLocationModal(e.latlng);
            } else if (isAddingBlasting) {
                showBlastingModal(e.latlng);
            } else if (isAddingMeasurement) {
                showMeasurementModal(e.latlng);
            }
        });
        
        // ìœ„ì¹˜ ì¶”ê°€ ëª¨ë‹¬ í‘œì‹œ
        function showLocationModal(latlng) {
            document.getElementById('location-modal').style.display = 'block';
            
            // í¼ ì œì¶œ ì´ë²¤íŠ¸
            document.getElementById('location-form').onsubmit = function(e) {
                e.preventDefault();
                addLocationMarker(latlng);
                closeLocationModal();
            };
        }
        
        // ë°œíŒŒ ëª¨ë‹¬ í‘œì‹œ
        function showBlastingModal(latlng) {
            // WGS84 ì¢Œí‘œë¥¼ EPSG:5186ìœ¼ë¡œ ë³€í™˜
            const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]);
            const coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`;
            
            // ê¸°ì¤€ì  ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ STA ê°’ ìë™ ê³„ì‚°
            const sta = calculateSTA(latlng);
            
            document.getElementById('blasting-coordinates').value = coordinates;
            document.getElementById('blasting-sta').value = sta;
            
            document.getElementById('blasting-modal').style.display = 'block';
            
            // í¼ ì œì¶œ ì´ë²¤íŠ¸
            document.getElementById('blasting-form').onsubmit = function(e) {
                e.preventDefault();
                addBlastingMarker(latlng);
                closeBlastingModal();
            };
        }
        
        // ê³„ì¸¡ ëª¨ë‹¬ í‘œì‹œ
        function showMeasurementModal(latlng) {
            // WGS84 ì¢Œí‘œë¥¼ EPSG:5186ìœ¼ë¡œ ë³€í™˜
            const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]);
            const coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`;
            
            // ê¸°ì¤€ì  ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ STA ê°’ ìë™ ê³„ì‚°
            const sta = calculateSTA(latlng);
            
            document.getElementById('measurement-coordinates').value = coordinates;
            document.getElementById('measurement-sta').value = sta;
            
            document.getElementById('measurement-modal').style.display = 'block';
            
            // í¼ ì œì¶œ ì´ë²¤íŠ¸
            document.getElementById('measurement-form').onsubmit = function(e) {
                e.preventDefault();
                addMeasurementMarker(latlng);
                closeMeasurementModal();
            };
        }
        
        // ìœ„ì¹˜ ì¶”ê°€ ëª¨ë‹¬ ë‹«ê¸°
        function closeLocationModal() {
            document.getElementById('location-modal').style.display = 'none';
            document.getElementById('location-form').reset();
        }
        
        // ë°œíŒŒ ëª¨ë‹¬ ë‹«ê¸°
        function closeBlastingModal() {
            document.getElementById('blasting-modal').style.display = 'none';
            document.getElementById('blasting-form').reset();
        }
        
        // ê³„ì¸¡ ëª¨ë‹¬ ë‹«ê¸°
        function closeMeasurementModal() {
            document.getElementById('measurement-modal').style.display = 'none';
            document.getElementById('measurement-form').reset();
        }
        

        

        

        
        // ìœ„ì¹˜ ë§ˆì»¤ ì¶”ê°€
        function addLocationMarker(latlng) {
            const name = document.getElementById('location-name').value;
            const description = document.getElementById('location-description').value;
            const category = document.getElementById('location-category').value;
            const tags = document.getElementById('location-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            // ìœ„ì¹˜ ë§ˆì»¤ ìƒì„±
            const markerIcon = L.divIcon({
                className: 'location-marker',
                html: `<div style="background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold;">ğŸ“</div>`,
                iconSize: [24, 24]
            });
            
            const marker = L.marker(latlng, {
                icon: markerIcon
            }).addTo(map);
            
            // íƒœê·¸ê°€ ìˆëŠ” ê²½ìš° ì§€ë„ì— ì§ì ‘ í…ìŠ¤íŠ¸ ë¼ë²¨ ì¶”ê°€
            if (tags.length > 0) {
                const tagLabel = L.divIcon({
                    className: 'tag-label',
                    html: `
                        <div style="background: white; color: #333; padding: 6px 10px; border-radius: 6px; font-size: 13px; font-weight: bold; white-space: nowrap; box-shadow: 0 3px 8px rgba(0,0,0,0.3); border: 2px solid #6f42c1; text-align: center; min-width: 60px;">
                            ${tags[0]}
                        </div>
                    `,
                    iconSize: [0, 0],
                    iconAnchor: [0, 0]
                });
                
                const tagMarker = L.marker(latlng, {
                    icon: tagLabel,
                    interactive: false
                }).addTo(map);
                
                // íƒœê·¸ ë¼ë²¨ì„ ë§ˆì»¤ ì˜¤ë¥¸ìª½ì— ë°°ì¹˜
                tagMarker.setLatLng([
                    latlng.lat,
                    latlng.lng + 0.00015 // ë§ˆì»¤ ì˜¤ë¥¸ìª½ì— ì ì ˆí•œ ì˜¤í”„ì…‹
                ]);
                
                // íƒœê·¸ ë§ˆì»¤ë¥¼ ìœ„ì¹˜ ë§ˆì»¤ì™€ í•¨ê»˜ ê´€ë¦¬
                locationMarkers.push({ marker: marker, tagMarker: tagMarker });
            } else {
                locationMarkers.push({ marker: marker, tagMarker: null });
            }
            
            // íŒì—… ì •ë³´ ì¶”ê°€
            const popupContent = `
                <div style="min-width: 200px;">
                    <h4 style="margin: 0 0 10px 0; color: #007bff;">${name}</h4>
                    ${category ? `<p style="margin: 5px 0; color: #666;"><strong>ì¹´í…Œê³ ë¦¬:</strong> ${category}</p>` : ''}
                    ${description ? `<p style="margin: 5px 0; color: #333;">${description}</p>` : ''}
                    ${tags.length > 0 ? `
                        <div style="margin: 10px 0;">
                            <p style="margin: 5px 0; color: #666;"><strong>íƒœê·¸:</strong></p>
                            <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                                ${tags.map(tag => `<span style="background: #ff6b35; color: white; padding: 3px 8px; border-radius: 12px; font-size: 11px;">${tag}</span>`).join('')}</div>
                        </div>
                    ` : ''}
                    <p style="margin: 5px 0; font-size: 12px; color: #999;">
                        ì¢Œí‘œ: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                    </p>
                    <button onclick="removeLocationMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">ì‚­ì œ</button>
                </div>
            `;
            
            marker.bindPopup(popupContent);
            
            // ìœ„ì¹˜ ì¶”ê°€ ëª¨ë“œ ë¹„í™œì„±í™”
            isAddingLocation = false;
            document.getElementById('add-location-btn').classList.remove('active');
            map.getContainer().style.cursor = '';
            
            // ìœ„ì¹˜ ì •ë³´ ì—…ë°ì´íŠ¸
            updateLocationInfo();
        }
        
        // ë°œíŒŒ ë§ˆì»¤ ì¶”ê°€
        function addBlastingMarker(latlng) {
            const blastingId = document.getElementById('blasting-id').value;
            const blastingSta = document.getElementById('blasting-sta').value;
            const blastingCoordinates = document.getElementById('blasting-coordinates').value;
            const blastingDepth = parseFloat(document.getElementById('blasting-depth').value);
            const blastingDescription = document.getElementById('blasting-description').value;
            
            // WGS84 ì¢Œí‘œë¥¼ EPSG:5186ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
            const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]);
            const epsg5186Coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`;
            
            // ë°œíŒŒ ë§ˆì»¤ ìƒì„± (ë¹¨ê°„ìƒ‰)
            const markerIcon = L.divIcon({
                className: 'blasting-marker',
                html: `<div style="background: #dc3545; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold;">ğŸ’¥</div>`,
                iconSize: [28, 28]
            });
            
            const marker = L.marker(latlng, {
                icon: markerIcon
            }).addTo(map);
            
            // ë°œíŒŒ ì •ë³´ë¥¼ ë§ˆì»¤ì— ì €ì¥
            marker.blastingData = {
                id: blastingId,
                sta: blastingSta,
                coordinates: epsg5186Coordinates, // EPSG:5186 ì¢Œí‘œë¡œ ì €ì¥
                depth: blastingDepth,
                description: blastingDescription,
                latlng: latlng,
                epsg5186: { x: x, y: y } // EPSG:5186 ì¢Œí‘œê°’ë„ ë³„ë„ë¡œ ì €ì¥
            };
            

            
            // íŒì—… ì •ë³´ ì¶”ê°€
            const popupContent = `
                <div style="min-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: #dc3545;">ğŸ’¥ ë°œíŒŒ ìœ„ì¹˜</h4>
                    <p style="margin: 5px 0; color: #333;"><strong>ë°œíŒŒ ID:</strong> ${blastingId}</p>
                    <p style="margin: 5px 0; color: #333;"><strong>STA.:</strong> ${blastingSta}</p>
                    <p style="margin: 5px 0; color: #333;"><strong>ì¢Œí‘œ:</strong> ${blastingCoordinates}</p>
                    <p style="margin: 5px 0; color: #333;"><strong>ê¹Šì´:</strong> ${blastingDepth}m</p>
                    ${blastingDescription ? `<p style="margin: 5px 0; color: #333;"><strong>ì„¤ëª…:</strong> ${blastingDescription}</p>` : ''}
                    <button onclick="removeBlastingMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">ì‚­ì œ</button>
                </div>
            `;
            
            marker.bindPopup(popupContent);
            
            // ë°œíŒŒ ë§ˆì»¤ ë°°ì—´ì— ì¶”ê°€
            blastingMarkers.push(marker);
            
            // ë°œíŒŒ ì¶”ê°€ ëª¨ë“œ ë¹„í™œì„±í™”
            isAddingBlasting = false;
            document.getElementById('add-blasting-btn').classList.remove('active');
            map.getContainer().style.cursor = '';
            
            // ë°œíŒŒ ì •ë³´ ì—…ë°ì´íŠ¸
            updateBlastingInfo();
        }
        
        // ê³„ì¸¡ ë§ˆì»¤ ì¶”ê°€
        function addMeasurementMarker(latlng) {
            const measurementSta = document.getElementById('measurement-sta').value;
            const measurementCoordinates = document.getElementById('measurement-coordinates').value;
            const measurementDescription = document.getElementById('measurement-description').value;
            
            // WGS84 ì¢Œí‘œë¥¼ EPSG:5186ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
            const [x, y] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]);
            const epsg5186Coordinates = `X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}`;
            
            // ê³„ì¸¡ ë§ˆì»¤ ìƒì„± (íŒŒë€ìƒ‰)
            const markerIcon = L.divIcon({
                className: 'measurement-marker',
                html: `<div style="background: #007bff; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold;">ğŸ“Š</div>`,
                iconSize: [28, 28]
            });
            
            const marker = L.marker(latlng, {
                icon: markerIcon
            }).addTo(map);
            
            // ê³„ì¸¡ ì •ë³´ë¥¼ ë§ˆì»¤ì— ì €ì¥
            marker.measurementData = {
                sta: measurementSta,
                coordinates: epsg5186Coordinates, // EPSG:5186 ì¢Œí‘œë¡œ ì €ì¥
                description: measurementDescription,
                latlng: latlng,
                epsg5186: { x: x, y: y } // EPSG:5186 ì¢Œí‘œê°’ë„ ë³„ë„ë¡œ ì €ì¥
            };
            

            
            // íŒì—… ì •ë³´ ì¶”ê°€
            const popupContent = `
                <div style="min-width: 250px;">
                    <h4 style="margin: 0 0 10px 0; color: #007bff;">ğŸ“Š ê³„ì¸¡ ìœ„ì¹˜</h4>
                    <p style="margin: 5px 0; color: #333;"><strong>STA.:</strong> ${measurementSta}</p>
                    <p style="margin: 5px 0; color: #333;"><strong>ì¢Œí‘œ:</strong> ${measurementCoordinates}</p>
                    ${measurementDescription ? `<p style="margin: 5px 0; color: #333;"><strong>ì„¤ëª…:</strong> ${measurementDescription}</p>` : ''}
                    <button onclick="removeMeasurementMarker(this)" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">ì‚­ì œ</button>
                </div>
            `;
            
            marker.bindPopup(popupContent);
            
            // ê³„ì¸¡ ë§ˆì»¤ ë°°ì—´ì— ì¶”ê°€
            measurementMarkers.push(marker);
            
            // ê³„ì¸¡ ì¶”ê°€ ëª¨ë“œ ë¹„í™œì„±í™”
            isAddingMeasurement = false;
            document.getElementById('add-measurement-btn').classList.remove('active');
            map.getContainer().style.cursor = '';
            
            // ë°œíŒŒ ì •ë³´ ì—…ë°ì´íŠ¸ (ê±°ë¦¬ ê³„ì‚° í¬í•¨)
            updateBlastingInfo();
        }
        
        // ìœ„ì¹˜ ë§ˆì»¤ ì‚­ì œ (ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡)
        window.removeLocationMarker = function(button) {
            const marker = button.closest('.leaflet-popup-content').__marker;
            if (marker) {
                // ìœ„ì¹˜ ë§ˆì»¤ì™€ íƒœê·¸ ë§ˆì»¤ ëª¨ë‘ ì°¾ì•„ì„œ ì‚­ì œ
                const locationData = locationMarkers.find(item => item.marker === marker);
                if (locationData) {
                    map.removeLayer(locationData.marker);
                    if (locationData.tagMarker) {
                        map.removeLayer(locationData.tagMarker);
                    }
                    
                    const index = locationMarkers.indexOf(locationData);
                    if (index > -1) {
                        locationMarkers.splice(index, 1);
                    }
                    
                    // ìœ„ì¹˜ ì •ë³´ ì—…ë°ì´íŠ¸
                    updateLocationInfo();
                }
            }
        };
        
        // ë°œíŒŒ ë§ˆì»¤ ì‚­ì œ (ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡)
        window.removeBlastingMarker = function(button) {
            const marker = button.closest('.leaflet-popup-content').__marker;
            if (marker) {
                map.removeLayer(marker);
                
                const index = blastingMarkers.indexOf(marker);
                if (index > -1) {
                    blastingMarkers.splice(index, 1);
                }
                
                // ë°œíŒŒ ì •ë³´ ì—…ë°ì´íŠ¸
                updateBlastingInfo();
            }
        };
        
        // ê³„ì¸¡ ë§ˆì»¤ ì‚­ì œ (ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡)
        window.removeMeasurementMarker = function(button) {
            const marker = button.closest('.leaflet-popup-content').__marker;
            if (marker) {
                map.removeLayer(marker);
                
                const index = measurementMarkers.indexOf(marker);
                if (index > -1) {
                    measurementMarkers.splice(index, 1);
                }
                
                // ë°œíŒŒ ì •ë³´ ì—…ë°ì´íŠ¸
                updateBlastingInfo();
            }
        };
        
        // ì „ì²´ ë§ˆì»¤ ì‚­ì œ
        function clearAllMarkers() {
            // ìœ„ì¹˜ ë§ˆì»¤ ì‚­ì œ
            locationMarkers.forEach(item => {
                map.removeLayer(item.marker);
                if (item.tagMarker) {
                    map.removeLayer(item.tagMarker);
                }
            });
            locationMarkers = [];
            
            // ë°œíŒŒ ë§ˆì»¤ ì‚­ì œ
            blastingMarkers.forEach(marker => map.removeLayer(marker));
            blastingMarkers = [];
            
            // ê³„ì¸¡ ë§ˆì»¤ ì‚­ì œ
            measurementMarkers.forEach(marker => map.removeLayer(marker));
            measurementMarkers = [];
            
            // ê±°ë¦¬ ì¸¡ì • ë§ˆì»¤ ì‚­ì œ
            distanceMarkers.forEach(marker => map.removeLayer(marker));
            distancePolylines.forEach(polyline => map.removeLayer(polyline));
            distanceMarkers = [];
            distancePolylines = [];
            currentDistancePoints = [];
            
            // ì •ë³´ ì—…ë°ì´íŠ¸
            updateLocationInfo();
            updateBlastingInfo();
            
            // ëª¨ë“œ ë¹„í™œì„±í™”
            isAddingLocation = false;
            isMeasuringDistance = false;
            isAddingBlasting = false;
            isAddingMeasurement = false;
            document.getElementById('add-location-btn').classList.remove('active');
            document.getElementById('measure-distance-btn').classList.remove('active');
            document.getElementById('add-blasting-btn').classList.remove('active');
            document.getElementById('add-measurement-btn').classList.remove('active');
            map.getContainer().style.cursor = '';
        }
        
        // ìœ„ì¹˜ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateLocationInfo() {
            const locationInfo = document.getElementById('location-info');
            if (locationMarkers.length === 0) {
                locationInfo.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 10px;">ì§€ë„ì—ì„œ ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>';
            } else {
                let infoHTML = '<div style="max-height: 200px; overflow-y: auto;">';
                locationMarkers.forEach((item, index) => {
                    const latlng = item.marker.getLatLng();
                    infoHTML += `
                        <div style="padding: 8px; margin: 5px 0; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #28a745;">
                            <div style="font-weight: bold; color: #333;">ìœ„ì¹˜ ${index + 1}</div>
                            <div style="font-size: 11px; color: #666;">ì¢Œí‘œ: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}</div>
                        </div>
                    `;
                });
                infoHTML += '</div>';
                locationInfo.innerHTML = infoHTML;
            }
        }
        
        // ë°œíŒŒ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateBlastingInfo() {
            const blastingInfo = document.getElementById('blasting-info');
            
            if (blastingMarkers.length === 0 && measurementMarkers.length === 0) {
                blastingInfo.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 10px;">ë°œíŒŒ ìœ„ì¹˜ì™€ ê³„ì¸¡ ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</div>';
                return;
            }
            
            let infoHTML = '<div style="max-height: 300px; overflow-y: auto;">';
            
            // ë°œíŒŒ ë§ˆì»¤ ì •ë³´
            if (blastingMarkers.length > 0) {
                infoHTML += '<h5 style="margin: 10px 0 5px 0; color: #dc3545;">ğŸ’¥ ë°œíŒŒ ìœ„ì¹˜</h5>';
                blastingMarkers.forEach((marker, index) => {
                    const data = marker.blastingData;
                    infoHTML += `
                        <div style="padding: 8px; margin: 5px 0; background: #fff5f5; border-radius: 4px; border-left: 3px solid #dc3545;">
                            <div style="font-weight: bold; color: #333;">ë°œíŒŒ ${index + 1}</div>
                            <div style="font-size: 11px; color: #666;">ID: ${data.id}</div>
                            <div style="font-size: 11px; color: #666;">STA.: ${data.sta}</div>
                            <div style="font-size: 11px; color: #666;">ê¹Šì´: ${data.depth}m</div>
                        </div>
                    `;
                });
            }
            
            // ê³„ì¸¡ ë§ˆì»¤ ì •ë³´
            if (measurementMarkers.length > 0) {
                infoHTML += '<h5 style="margin: 15px 0 5px 0; color: #007bff;">ğŸ“Š ê³„ì¸¡ ìœ„ì¹˜</h5>';
                measurementMarkers.forEach((marker, index) => {
                    const data = marker.measurementData;
                    infoHTML += `
                        <div style="padding: 8px; margin: 5px 0; background: #f0f8ff; border-radius: 4px; border-left: 3px solid #007bff;">
                            <div style="font-weight: bold; color: #333;">ê³„ì¸¡ ${index + 1}</div>
                            <div style="font-size: 11px; color: #666;">STA.: ${data.sta}</div>
                        </div>
                    `;
                });
            }
            
            // ê±°ë¦¬ ê³„ì‚° ê²°ê³¼
            if (blastingMarkers.length > 0 && measurementMarkers.length > 0) {
                infoHTML += '<h5 style="margin: 15px 0 5px 0; color: #28a745;">ğŸ“ ê±°ë¦¬ ê³„ì‚° ê²°ê³¼</h5>';
                
                blastingMarkers.forEach((blastingMarker, bIndex) => {
                    const blastingData = blastingMarker.blastingData;
                    
                    measurementMarkers.forEach((measurementMarker, mIndex) => {
                        const measurementData = measurementMarker.measurementData;
                        
                        // Turf.jsë¥¼ ì‚¬ìš©í•œ ìˆ˜í‰ ê±°ë¦¬ ê³„ì‚°
                        const horizontalDistance = turf.distance(
                            turf.point([blastingData.latlng.lng, blastingData.latlng.lat]),
                            turf.point([measurementData.latlng.lng, measurementData.latlng.lat]),
                            { units: 'meters' }
                        );
                        
                        // 3D ê±°ë¦¬ ê³„ì‚° (í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬)
                        const verticalDistance = blastingData.depth;
                        const threeDDistance = Math.sqrt(horizontalDistance * horizontalDistance + verticalDistance * verticalDistance);
                        
                        infoHTML += `
                            <div style="padding: 8px; margin: 5px 0; background: #f8fff8; border-radius: 4px; border-left: 3px solid #28a745;">
                                <div style="font-weight: bold; color: #333;">ë°œíŒŒ ${bIndex + 1} â†” ê³„ì¸¡ ${mIndex + 1}</div>
                                <div style="font-size: 11px; color: #666;">ìˆ˜í‰ ê±°ë¦¬: ${horizontalDistance.toFixed(2)}m</div>
                                <div style="font-size: 11px; color: #666;">3D ê±°ë¦¬: ${threeDDistance.toFixed(2)}m</div>
                                <div style="font-size: 11px; color: #666;">ê¹Šì´: ${verticalDistance}m</div>
                            </div>
                        `;
                    });
                });
            }
            
            infoHTML += '</div>';
            blastingInfo.innerHTML = infoHTML;
        }
        
        // íŒì—…ì— ë§ˆì»¤ ì°¸ì¡° ì¶”ê°€
        map.on('popupopen', function(e) {
            if (e.popup && e.popup.getContent) {
                const content = e.popup.getContent();
                if (content && content.includes('removeLocationMarker')) {
                    e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target;
                } else if (content && content.includes('removeBlastingMarker')) {
                    e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target;
                } else if (content && content.includes('removeMeasurementMarker')) {
                    e.popup.getElement().querySelector('.leaflet-popup-content').__marker = e.target;
                }
            }
        });

        // --- 2. DXF ë Œë”ë§ ë¡œì§ (ëŒ€í­ ê°œì„ ) ---
        // GeoJSON íŒŒì¼ ë¡œë“œ
        const geojsonInput = document.getElementById('geojson-input');
        geojsonInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geojsonData = JSON.parse(e.target.result);
                    routeData = geojsonData;
                    
                    // ê¸°ì¡´ ë…¸ì„  ë ˆì´ì–´ ì œê±°
                    if (routeLayer) {
                        map.removeLayer(routeLayer);
                    }
                    
                    // ì¢Œí‘œê³„ ë³€í™˜ì„ ìœ„í•œ í•¨ìˆ˜
                    function transformCoordinates(feature) {
                        if (feature.geometry && feature.geometry.coordinates) {
                            if (feature.geometry.type === 'LineString') {
                                feature.geometry.coordinates = feature.geometry.coordinates.map(coord => {
                                    // EPSG:5186 â†’ WGS84 ë³€í™˜
                                    const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord);
                                    return [lng, lat];
                                });
                            } else if (feature.geometry.type === 'Point') {
                                const coord = feature.geometry.coordinates;
                                const [lng, lat] = proj4('EPSG:5186', 'EPSG:4326', coord);
                                feature.geometry.coordinates = [lng, lat];
                            }
                        }
                        return feature;
                    }
                    
                    // ëª¨ë“  í”¼ì²˜ì— ëŒ€í•´ ì¢Œí‘œê³„ ë³€í™˜ ì ìš©
                    const transformedData = {
                        ...geojsonData,
                        features: geojsonData.features.map(transformCoordinates)
                    };
                    
                    // ìƒˆë¡œìš´ ë…¸ì„  ë ˆì´ì–´ ì¶”ê°€ (ë³€í™˜ëœ ì¢Œí‘œ ì‚¬ìš©)
                    routeLayer = L.geoJSON(transformedData, {
                        style: {
                            color: '#ff6b35',
                            weight: 3,
                            opacity: 0.8
                        }
                    }).addTo(map);
                    
                    // ë…¸ì„ ì— ë§ì¶° ì§€ë„ ë·° ì¡°ì •
                    if (geojsonData.features && geojsonData.features.length > 0) {
                        map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
                    }
                    
                    document.getElementById('geojson-status').textContent = 'ë…¸ì„  ë°ì´í„° ë¡œë“œ ì™„ë£Œ!';
                    console.log('GeoJSON ë…¸ì„  ë°ì´í„° ë¡œë“œë¨:', geojsonData);
                    
                } catch (error) {
                    console.error('GeoJSON íŒŒì¼ íŒŒì‹± ì˜¤ë¥˜:', error);
                    document.getElementById('geojson-status').textContent = 'ë…¸ì„  íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨.';
                }
            };
            reader.readAsText(file);
        });

        const dxfInput = document.getElementById('dxf-input');
        dxfInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = 'íŒŒì¼ ì²˜ë¦¬ ì¤‘...';
                
                // ê¸°ì¡´ ë ˆì´ì–´ ì´ˆê¸°í™”
                dxfLayerGroup.clearLayers();
                layerGroups.clear();
                document.getElementById('layer-control').innerHTML = '';

                try {
                    // ë¨¼ì € ìƒˆë¡œìš´ DXF íŒŒì„œ ì‹œë„
                    let CadData;
                    if (typeof DXF !== 'undefined' && DXF.Helper) {
                        try {
                            const helper = new DXF.Helper(e.target.result);
                            CadData = helper.getCadData();
                            console.log('ìƒˆë¡œìš´ DXF íŒŒì„œë¡œ ì„±ê³µ:', CadData);
                        } catch (newParserError) {
                            console.log('ìƒˆë¡œìš´ íŒŒì„œ ì‹¤íŒ¨, ê¸°ì¡´ íŒŒì„œ ì‹œë„:', newParserError);
                            throw newParserError; // ê¸°ì¡´ íŒŒì„œë¡œ ë„˜ì–´ê°€ê¸° ìœ„í•´ ì—ëŸ¬ ë°œìƒ
                        }
                    } else {
                        throw new Error('DXF.Helperë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    }

                    if (!CadData.entities || CadData.entities.length === 0) {
                        statusEl.textContent = 'ë„í˜• ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                        return;
                    }

                    // DXF íŒŒì¼ êµ¬ì¡° ìƒì„¸ ë¶„ì„ (ìƒˆë¡œìš´ íŒŒì„œ)
                    console.log('ìƒˆë¡œìš´ íŒŒì„œ - DXF í—¤ë” ì •ë³´:', CadData.header);
                    console.log('ìƒˆë¡œìš´ íŒŒì„œ - DXF í…Œì´ë¸” ì •ë³´:', CadData.tables);
                    console.log('ìƒˆë¡œìš´ íŒŒì„œ - DXF ë¸”ë¡ ì •ë³´:', CadData.blocks);
                    
                    // ëª¨ë“  ë ˆì´ì–´ ì •ë³´ ìˆ˜ì§‘ (ìƒˆë¡œìš´ íŒŒì„œ)
                    const allLayers = new Set();
                    CadData.entities.forEach(entity => {
                        if (entity.layer) allLayers.add(entity.layer);
                    });
                    console.log('ìƒˆë¡œìš´ íŒŒì„œ - ë°œê²¬ëœ ëª¨ë“  ë ˆì´ì–´:', Array.from(allLayers));

                    // ì¢Œí‘œê³„ ìë™ ê°ì§€
                    const firstPoint = findFirstPoint(CadData.entities);
                    const detectedEPSG = detectCoordinateSystem(firstPoint);
                    statusEl.textContent = `ì¢Œí‘œê³„ ê°ì§€: EPSG:${detectedEPSG}. ë„í˜• ë Œë”ë§ ì¤‘...`;

                    // ê° ë„í˜•(entity)ì„ ì§€ë„ì— ê·¸ë¦¬ê¸°
                    const allLatLngs = [];
                    console.log('ì´ ì—”í‹°í‹° ìˆ˜:', CadData.entities.length);
                    
                    for (const entity of CadData.entities) {
                        console.log('ì—”í‹°í‹° íƒ€ì…:', entity.type, 'ë ˆì´ì–´:', entity.layer);
                        
                        const geometry = entityToLatLngs(entity, detectedEPSG);
                        if (geometry.latlngs.length > 0) {
                            const layerName = entity.layer || '0';
                            const style = getStyleForEntity(entity, CadData.tables ? CadData.tables.layers : null);
                            
                            const layerGroup = getOrCreateLayerGroup(layerName, style.color);
                            
                            if(geometry.type === 'polyline') {
                                L.polyline(geometry.latlngs, style).addTo(layerGroup);
                            } else if(geometry.type === 'circle') {
                                L.circle(geometry.latlngs[0], { ...style, radius: geometry.radius }).addTo(layerGroup);
                            } else if(geometry.type === 'hatch') {
                                // HATCH ì—”í‹°í‹°ë¥¼ í´ë¦¬ê³¤ìœ¼ë¡œ ë Œë”ë§
                                L.polygon(geometry.latlngs, {
                                    fillColor: '#FFFF00',
                                    color: '#FFD700',
                                    weight: 2,
                                    opacity: 0.3,
                                    fillOpacity: 0.1
                                }).addTo(layerGroup);
                            } else if(geometry.type === 'text') {
                                // í…ìŠ¤íŠ¸ ê°ì²´ ë Œë”ë§
                                const textContent = entity.text || entity.textString || 'TEXT';
                                
                                // í…ìŠ¤íŠ¸ ìœ„ì¹˜ì— ì§ì ‘ HTML ìš”ì†Œ ì¶”ê°€
                                const textDiv = L.divIcon({
                                    className: 'text-marker',
                                    html: `<div style="color: black; padding: 2px 6px; font-size: 12px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-weight: bold;">${textContent}</div>`,
                                    iconSize: [0, 0],
                                    iconAnchor: [0, 0]
                                });
                                
                                const textMarker = L.marker(geometry.latlngs[0], {
                                    icon: textDiv,
                                    interactive: true
                                }).addTo(layerGroup);
                                
                                // í…ìŠ¤íŠ¸ íŒì—… ì¶”ê°€
                                textMarker.bindPopup(`
                                    <div style="min-width: 150px;">
                                        <strong>í…ìŠ¤íŠ¸:</strong> ${textContent}<br>
                                        <strong>ë ˆì´ì–´:</strong> ${layerName}<br>
                                        <strong>ì¢Œí‘œ:</strong> ${geometry.latlngs[0][0].toFixed(6)}, ${geometry.latlngs[0][1].toFixed(6)}
                                    </div>
                                `);
                                
                                console.log('ìƒˆë¡œìš´ íŒŒì„œ - í…ìŠ¤íŠ¸ ë Œë”ë§ ì„±ê³µ:', textContent, 'ë ˆì´ì–´:', layerName, 'ì¢Œí‘œ:', geometry.latlngs[0]);
                            } else if(geometry.type === 'point') {
                                // ì  ê°ì²´ ë Œë”ë§
                                L.circleMarker(geometry.latlngs[0], {
                                    radius: 3,
                                    fillColor: '#ff0000',
                                    color: '#000',
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(layerGroup);
                            }
                            allLatLngs.push(...geometry.latlngs);
                        } else {
                            console.log('ë³€í™˜ ì‹¤íŒ¨í•œ ì—”í‹°í‹°:', entity.type, entity);
                        }
                    }

                    if (allLatLngs.length > 0) {
                        map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
                        statusEl.textContent = `${CadData.entities.length}ê°œ ë„í˜• ë¡œë“œ ì™„ë£Œ!`;
                    } else {
                        statusEl.textContent = 'ìœ íš¨í•œ ë„í˜•ì„ ë³€í™˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                    }

                } catch (err) {
                    console.log('ìƒˆë¡œìš´ íŒŒì„œ ì‹¤íŒ¨, ê¸°ì¡´ íŒŒì„œë¡œ ì‹œë„:', err);
                    
                    // ê¸°ì¡´ íŒŒì„œë¡œ ì¬ì‹œë„
                    try {
                        const parser = new DxfParser();
                        const dxf = parser.parseSync(e.target.result);
                        console.log('ê¸°ì¡´ íŒŒì„œë¡œ ì„±ê³µ:', dxf);
                        
                        // DXF íŒŒì¼ êµ¬ì¡° ìƒì„¸ ë¶„ì„
                        console.log('DXF í—¤ë” ì •ë³´:', dxf.header);
                        console.log('DXF í…Œì´ë¸” ì •ë³´:', dxf.tables);
                        console.log('DXF ë¸”ë¡ ì •ë³´:', dxf.blocks);
                        
                        if (!dxf.entities || dxf.entities.length === 0) {
                            statusEl.textContent = 'ë„í˜• ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                            return;
                        }
                        
                        // ëª¨ë“  ë ˆì´ì–´ ì •ë³´ ìˆ˜ì§‘
                        const allLayers = new Set();
                        dxf.entities.forEach(entity => {
                            if (entity.layer) allLayers.add(entity.layer);
                        });
                        console.log('ë°œê²¬ëœ ëª¨ë“  ë ˆì´ì–´:', Array.from(allLayers));
                        
                        // ì¢Œí‘œê³„ ìë™ ê°ì§€
                        const firstPoint = findFirstPointLegacy(dxf.entities);
                        const detectedEPSG = detectCoordinateSystem(firstPoint);
                        statusEl.textContent = `ì¢Œí‘œê³„ ê°ì§€: EPSG:${detectedEPSG}. ë„í˜• ë Œë”ë§ ì¤‘...`;

                        // ê° ë„í˜•ì„ ì§€ë„ì— ê·¸ë¦¬ê¸°
                        const allLatLngs = [];
                        console.log('ê¸°ì¡´ íŒŒì„œ - ì´ ì—”í‹°í‹° ìˆ˜:', dxf.entities.length);
                        
                        for (const entity of dxf.entities) {
                            console.log('ê¸°ì¡´ íŒŒì„œ - ì—”í‹°í‹° íƒ€ì…:', entity.type, 'ë ˆì´ì–´:', entity.layer);
                            
                            const geometry = entityToLatLngsLegacy(entity, detectedEPSG);
                            if (geometry.latlngs.length > 0) {
                                const layerName = entity.layer || '0';
                                const style = getStyleForEntityLegacy(entity);
                                
                                const layerGroup = getOrCreateLayerGroup(layerName, style.color);
                                
                                if(geometry.type === 'polyline') {
                                    L.polyline(geometry.latlngs, style).addTo(layerGroup);
                                } else if(geometry.type === 'circle') {
                                    L.circle(geometry.latlngs[0], { ...style, radius: geometry.radius }).addTo(layerGroup);
                                } else if(geometry.type === 'hatch') {
                                    // HATCH ì—”í‹°í‹°ë¥¼ í´ë¦¬ê³¤ìœ¼ë¡œ ë Œë”ë§ (ê¸°ì¡´ íŒŒì„œìš©)
                                    L.polygon(geometry.latlngs, {
                                        fillColor: '#FFFF00',
                                        color: '#FFD700',
                                        weight: 2,
                                        opacity: 0.3,
                                        fillOpacity: 0.1
                                    }).addTo(layerGroup);
                                } else if(geometry.type === 'text') {
                                // í…ìŠ¤íŠ¸ ê°ì²´ ë Œë”ë§ (ê¸°ì¡´ íŒŒì„œìš©)
                                const textContent = entity.text || entity.textString || 'TEXT';
                                
                                // í…ìŠ¤íŠ¸ ìœ„ì¹˜ì— ì§ì ‘ HTML ìš”ì†Œ ì¶”ê°€
                                const textDiv = L.divIcon({
                                    className: 'text-marker',
                                    html: `<div style="color: black; padding: 2px 6px; font-size: 12px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-weight: bold;">${textContent}</div>`,
                                    iconSize: [0, 0],
                                    iconAnchor: [0, 0]
                                });
                                
                                const textMarker = L.marker(geometry.latlngs[0], {
                                    icon: textDiv,
                                    interactive: true
                                }).addTo(layerGroup);
                                
                                // í…ìŠ¤íŠ¸ íŒì—… ì¶”ê°€
                                textMarker.bindPopup(`
                                    <div style="min-width: 150px;">
                                        <strong>í…ìŠ¤íŠ¸:</strong> ${textContent}<br>
                                        <strong>ë ˆì´ì–´:</strong> ${layerName}<br>
                                        <strong>ì¢Œí‘œ:</strong> ${geometry.latlngs[0][0].toFixed(6)}, ${geometry.latlngs[0][1].toFixed(6)}
                                    </div>
                                `);
                                
                                console.log('í…ìŠ¤íŠ¸ ë Œë”ë§ ì„±ê³µ:', textContent, 'ë ˆì´ì–´:', layerName, 'ì¢Œí‘œ:', geometry.latlngs[0]);
                            } else if(geometry.type === 'point') {
                                    // ì  ê°ì²´ ë Œë”ë§ (ê¸°ì¡´ íŒŒì„œìš©)
                                    L.circleMarker(geometry.latlngs[0], {
                                        radius: 3,
                                        fillColor: '#ff0000',
                                        color: '#000',
                                        weight: 1,
                                        opacity: 1,
                                        fillOpacity: 0.8
                                    }).addTo(layerGroup);
                                }
                                allLatLngs.push(...geometry.latlngs);
                            } else {
                                console.log('ê¸°ì¡´ íŒŒì„œ - ë³€í™˜ ì‹¤íŒ¨í•œ ì—”í‹°í‹°:', entity.type, entity);
                            }
                        }

                        if (allLatLngs.length > 0) {
                            map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
                            statusEl.textContent = `${dxf.entities.length}ê°œ ë„í˜• ë¡œë“œ ì™„ë£Œ! (ê¸°ì¡´ íŒŒì„œ)`;
                        } else {
                            statusEl.textContent = 'ìœ íš¨í•œ ë„í˜•ì„ ë³€í™˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                        }
                        
                    } catch (legacyError) {
                        console.error('ëª¨ë“  DXF íŒŒì„œ ì‹¤íŒ¨:', legacyError);
                        statusEl.textContent = 'DXF íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.';
                    }
                }
            };
            reader.readAsText(file, 'UTF-8');
        });

        // --- 3. í—¬í¼ í•¨ìˆ˜ë“¤ ---
 
         function findFirstPoint(entities) {
             for(const entity of entities) {
                 if(entity.vertices && entity.vertices.length > 0) return entity.vertices[0];
                 if(entity.startPoint) return entity.startPoint;
                 if(entity.center) return entity.center;
             }
             return null;
         }
         
         // ê¸°ì¡´ íŒŒì„œìš© í—¬í¼ í•¨ìˆ˜ë“¤
         function findFirstPointLegacy(entities) {
             for(const entity of entities) {
                 if(entity.vertices && entity.vertices.length > 0) return entity.vertices[0];
                 if(entity.startPoint) return entity.startPoint;
                 if(entity.center) return entity.center;
             }
             return null;
         }
 
         function detectCoordinateSystem(point) {
             if (!point) return "5186"; // ì ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜
             
             console.log('ì¢Œí‘œê³„ ê°ì§€ - ì…ë ¥ ì¢Œí‘œ:', point);
             
             // ë” ë§ì€ í•œêµ­ ì¢Œí‘œê³„ ì§€ì›
             const epsgCodes = ["5186", "5179", "5181", "5187", "5188", "5189", "5190", "5191", "5192", "5193", "5194", "5195", "5196", "5197", "5198", "5199"];
             
             for (const code of epsgCodes) {
                 try {
                     const [lon, lat] = proj4(`EPSG:${code}`, "EPSG:4326", [point.x, point.y]);
                     console.log(`EPSG:${code} ë³€í™˜ ê²°ê³¼:`, lon, lat);
                     
                     // í•œêµ­ ì˜ì—­ ë‚´ ì¢Œí‘œì¸ì§€ í™•ì¸ (ë” ë„“ì€ ë²”ìœ„)
                     if (lat >= 30 && lat <= 45 && lon >= 120 && lon <= 140) {
                         console.log(`ì¢Œí‘œê³„ ê°ì§€ ì„±ê³µ: EPSG:${code}`);
                         return code;
                     }
                 } catch (e) {
                     console.log(`EPSG:${code} ë³€í™˜ ì‹¤íŒ¨:`, e.message);
                 }
             }
             
             console.log('ì¢Œí‘œê³„ ê°ì§€ ì‹¤íŒ¨, ê¸°ë³¸ê°’ EPSG:5186 ì‚¬ìš©');
             return "5186"; // ê°ì§€ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’
         }
 
         function getOrCreateLayerGroup(layerName, color) {
             if (!layerGroups.has(layerName)) {
                 const group = L.layerGroup();
                 layerGroups.set(layerName, group);
 
                 // ë ˆì´ì–´ ì»¨íŠ¸ë¡¤ UI ì¶”ê°€
                 const controlEl = document.getElementById('layer-control');
                 const div = document.createElement('div');
                 div.className = 'layer-item'; // ìƒˆë¡œìš´ í´ë˜ìŠ¤ ì¶”ê°€
                 div.innerHTML = `
                     <input type="checkbox" id="layer-${layerName}" checked>
                     <label for="layer-${layerName}" style="color:${color};">${layerName}</label>
                     <input type="range" class="layer-opacity" min="0" max="1" step="0.1" value="1" onchange="setLayerOpacity(this.id.replace('layer-', ''), this.value)">
                 `;
                 controlEl.appendChild(div);
 
                 div.querySelector('input[type="checkbox"]').addEventListener('change', function() {
                     if (this.checked) {
                         group.addTo(dxfLayerGroup);
                     } else {
                         dxfLayerGroup.removeLayer(group);
                     }
                 });
                 
                 div.querySelector('.layer-opacity').addEventListener('input', function() {
                     setLayerOpacity(layerName, this.value);
                 });
                 
                 // ì´ˆê¸° ìƒíƒœë¡œ ë ˆì´ì–´ ì¶”ê°€
                 group.addTo(dxfLayerGroup);
             }
             return layerGroups.get(layerName);
         }
         
         function getStyleForEntity(entity, layerTable) {
             const layerName = entity.layer || '0';
             const layerInfo = layerTable ? layerTable[layerName] : null;
             let color = '#FFFF00'; // ê¸°ë³¸ìƒ‰: ë…¸ë€ìƒ‰
 
             if (entity.colorNumber) {
                  color = DXF.ACAD_COLOR_PALETTE[entity.colorNumber] ? '#' + DXF.ACAD_COLOR_PALETTE[entity.colorNumber].toString(16).padStart(6, '0') : color;
             } else if (layerInfo && layerInfo.colorNumber) {
                  color = DXF.ACAD_COLOR_PALETTE[layerInfo.colorNumber] ? '#' + DXF.ACAD_COLOR_PALETTE[layerInfo.colorNumber].toString(16).padStart(6, '0') : color;
             }
             
             return { color: color, weight: 1, opacity: 0.95 };
         }
         
         // ê¸°ì¡´ íŒŒì„œìš© ìŠ¤íƒ€ì¼ í•¨ìˆ˜
         function getStyleForEntityLegacy(entity) {
             const layerName = entity.layer || '0';
             let color = '#FFFF00'; // ê¸°ë³¸ìƒ‰: ë…¸ë€ìƒ‰
             
             // ë ˆì´ì–´ë³„ ìƒ‰ìƒ ë§¤í•‘
             const layerColors = {
                 '0': '#FFFF00', 'WALL': '#FFFF00', 'DOOR': '#00FF00', 'WINDOW': '#0000FF',
                 'DIMENSION': '#FFFF00', 'TEXT': '#FF00FF', 'HATCH': '#00FFFF', 'CENTER': '#FF8000',
                 'HIDDEN': '#808080', 'BORDER': '#FF0000', 'UTILITY': '#008000', 'EQUIPMENT': '#800000',
                 'ANNOTATION': '#000080', 'ROAD': '#FFFF00', 'BUILDING': '#FFFF00', 'STRUCTURE': '#FF0000',
                 'PIPE': '#00FFFF', 'ELECTRICAL': '#FF00FF', 'MECHANICAL': '#FF8000'
             };
             
             if (layerColors[layerName]) {
                 color = layerColors[layerName];
             }
             
             return { color: color, weight: 0.8, opacity: 0.95 };
         }
 
         function entityToLatLngs(entity, epsg) {
             let latlngs = [], type = 'polyline', radius = 0;
             const transform = (p) => {
                 if(!p || typeof p.x === 'undefined' || typeof p.y === 'undefined') return null;
                 const [lon, lat] = proj4(`EPSG:${epsg}`, "EPSG:4326", [p.x, p.y]);
                 return [lat, lon];
             };
 
             switch (entity.type) {
                 case 'LINE':
                     latlngs = [transform(entity.startPoint), transform(entity.endPoint)].filter(p => p);
                     break;
                 case 'LWPOLYLINE':
                 case 'POLYLINE':
                     latlngs = entity.vertices.map(transform).filter(p => p);
                     break;
                 case 'CIRCLE':
                     const centerLatLng = transform(entity.center);
                     if(centerLatLng) {
                         latlngs.push(centerLatLng);
                         // ì›ì˜ ë°˜ì§€ë¦„ì„ ì§€ë„ ë‹¨ìœ„(ë¯¸í„°)ë¡œ ê·¼ì‚¬ ê³„ì‚°
                         const edgePoint = { x: entity.center.x + entity.radius, y: entity.center.y };
                         const edgeLatLng = transform(edgePoint);
                         radius = L.latLng(centerLatLng).distanceTo(L.latLng(edgeLatLng));
                         type = 'circle';
                     }
                     break;
                 case 'ARC':
                     // ARCë¥¼ Polylineìœ¼ë¡œ ê·¼ì‚¬í™” (10ê°œ ì  ì‚¬ìš©)
                     const arcPoints = [];
                     const startAngle = entity.startAngle * Math.PI / 180;
                     const endAngle = entity.endAngle * Math.PI / 180;
                     const angleStep = (endAngle - startAngle) / 10;
                     for (let i = 0; i <= 10; i++) {
                         const angle = startAngle + i * angleStep;
                         arcPoints.push({
                             x: entity.center.x + entity.radius * Math.cos(angle),
                             y: entity.center.y + entity.radius * Math.sin(angle)
                         });
                     }
                     latlngs = arcPoints.map(transform).filter(p => p);
                     break;
                 // ìš©ì§€ë„ ê´€ë ¨ ì¶”ê°€ ì—”í‹°í‹°ë“¤
                 case 'TEXT':
                 case 'MTEXT':
                     if (entity.startPoint) {
                         latlngs = [transform(entity.startPoint)];
                         type = 'text';
                     }
                     break;
                 case 'DIMENSION':
                     if (entity.definitionPoint) {
                         latlngs = [transform(entity.definitionPoint)];
                         type = 'dimension';
                     }
                     break;
                 case 'HATCH':
                     if (entity.boundaryPaths && entity.boundaryPaths.length > 0) {
                         // HATCHì˜ ê²½ê³„ì„ ì„ Polylineìœ¼ë¡œ ë³€í™˜
                         for (const path of entity.boundaryPaths) {
                             if (path.edges) {
                                 for (const edge of path.edges) {
                                     if (edge.type === 'LINE') {
                                         latlngs.push(transform(edge.startPoint), transform(edge.endPoint));
                                     }
                                 }
                             }
                         }
                     }
                     break;
                 case 'INSERT':
                     if (entity.insertionPoint) {
                         latlngs = [transform(entity.insertionPoint)];
                         type = 'insert';
                     }
                     break;
                 case 'POINT':
                     if (entity.position) {
                         latlngs = [transform(entity.position)];
                         type = 'point';
                     }
                     break;
                 case 'SPLINE':
                     if (entity.controlPoints && entity.controlPoints.length > 0) {
                         // SPLINEì„ ê·¼ì‚¬í™”í•˜ì—¬ Polylineìœ¼ë¡œ ë³€í™˜
                         latlngs = entity.controlPoints.map(transform).filter(p => p);
                         type = 'spline';
                     }
                     break;
                 case 'ELLIPSE':
                     if (entity.center) {
                         const centerLatLng = transform(entity.center);
                         if (centerLatLng) {
                             latlngs.push(centerLatLng);
                             // íƒ€ì›ì„ ì›ìœ¼ë¡œ ê·¼ì‚¬í™”
                             const majorAxis = entity.majorAxis || { x: 1, y: 0 };
                             const majorPoint = { 
                                 x: entity.center.x + majorAxis.x, 
                                 y: entity.center.y + majorAxis.y 
                             };
                             const majorLatLng = transform(majorPoint);
                             if (majorLatLng) {
                                 radius = L.latLng(centerLatLng).distanceTo(L.latLng(majorLatLng));
                                 type = 'ellipse';
                             }
                         }
                     }
                     break;
             }
             return { latlngs, type, radius };
         }
         
         // ê¸°ì¡´ íŒŒì„œìš© ì—”í‹°í‹° ë³€í™˜ í•¨ìˆ˜
         function entityToLatLngsLegacy(entity, epsg) {
             let latlngs = [], type = 'polyline', radius = 0;
             const transform = (p) => {
                 if(!p || typeof p.x === 'undefined' || typeof p.y === 'undefined') return null;
                 const [lon, lat] = proj4(`EPSG:${epsg}`, "EPSG:4326", [p.x, p.y]);
                 return [lat, lon];
             };
 
             switch (entity.type) {
                 case 'LINE':
                     if (entity.vertices && entity.vertices.length >= 2) {
                         latlngs = [transform(entity.vertices[0]), transform(entity.vertices[1])].filter(p => p);
                     }
                     break;
                 case 'LWPOLYLINE':
                 case 'POLYLINE':
                     if (entity.vertices && entity.vertices.length >= 2) {
                         latlngs = entity.vertices.map(transform).filter(p => p);
                     }
                     break;
                 case 'CIRCLE':
                     if (entity.center) {
                         const centerLatLng = transform(entity.center);
                         if(centerLatLng) {
                             latlngs.push(centerLatLng);
                             // ì›ì˜ ë°˜ì§€ë¦„ì„ ì§€ë„ ë‹¨ìœ„(ë¯¸í„°)ë¡œ ê·¼ì‚¬ ê³„ì‚°
                             const edgePoint = { x: entity.center.x + entity.radius, y: entity.center.y };
                             const edgeLatLng = transform(edgePoint);
                             if (edgeLatLng) {
                                 radius = L.latLng(centerLatLng).distanceTo(L.latLng(edgeLatLng));
                                 type = 'circle';
                             }
                         }
                     }
                     break;
                 case 'ARC':
                     if (entity.center && entity.radius && entity.startAngle !== undefined && entity.endAngle !== undefined) {
                         // ARCë¥¼ Polylineìœ¼ë¡œ ê·¼ì‚¬í™” (10ê°œ ì  ì‚¬ìš©)
                         const arcPoints = [];
                         const startAngle = entity.startAngle * Math.PI / 180;
                         const endAngle = entity.endAngle * Math.PI / 180;
                         const angleStep = (endAngle - startAngle) / 10;
                         for (let i = 0; i <= 10; i++) {
                             const angle = startAngle + i * angleStep;
                             arcPoints.push({
                                 x: entity.center.x + entity.radius * Math.cos(angle),
                                 y: entity.center.y + entity.radius * Math.sin(angle)
                             });
                         }
                         latlngs = arcPoints.map(transform).filter(p => p);
                     }
                     break;
                 // ìš©ì§€ë„ ê´€ë ¨ ì¶”ê°€ ì—”í‹°í‹°ë“¤ (ê¸°ì¡´ íŒŒì„œìš©)
                 case 'TEXT':
                 case 'MTEXT':
                     if (entity.startPoint) {
                         latlngs = [transform(entity.startPoint)];
                         type = 'text';
                     }
                     break;
                 case 'DIMENSION':
                     if (entity.definitionPoint) {
                         latlngs = [transform(entity.definitionPoint)];
                         type = 'dimension';
                     }
                     break;
                 case 'HATCH':
                     if (entity.boundaryPaths && entity.boundaryPaths.length > 0) {
                         // HATCHì˜ ê²½ê³„ì„ ì„ Polylineìœ¼ë¡œ ë³€í™˜í•˜ê³  ë©´ì  ì±„ìš°ê¸°
                         for (const path of entity.boundaryPaths) {
                             if (path.edges) {
                                 const boundaryPoints = [];
                                 for (const edge of path.edges) {
                                     if (edge.type === 'LINE') {
                                         const startPoint = transform(edge.startPoint);
                                         const endPoint = transform(edge.endPoint);
                                         if (startPoint && endPoint) {
                                             boundaryPoints.push(startPoint, endPoint);
                                         }
                                     }
                                 }
                                 if (boundaryPoints.length >= 3) {
                                     // ë©´ì  ì±„ìš°ê¸°ë¥¼ ìœ„í•œ í´ë¦¬ê³¤ ìƒì„±
                                     latlngs = boundaryPoints;
                                     type = 'hatch';
                                 }
                             }
                         }
                     }
                     break;
                 case 'INSERT':
                     if (entity.insertionPoint) {
                         latlngs = [transform(entity.insertionPoint)];
                         type = 'insert';
                     }
                     break;
                 case 'POINT':
                     if (entity.position) {
                         latlngs = [transform(entity.position)];
                         type = 'point';
                     }
                     break;
                 case 'SPLINE':
                     if (entity.controlPoints && entity.controlPoints.length > 0) {
                         // SPLINEì„ ê·¼ì‚¬í™”í•˜ì—¬ Polylineìœ¼ë¡œ ë³€í™˜
                         latlngs = entity.controlPoints.map(transform).filter(p => p);
                         type = 'spline';
                     }
                     break;
                 case 'ELLIPSE':
                     if (entity.center) {
                         const centerLatLng = transform(entity.center);
                         if (centerLatLng) {
                             latlngs.push(centerLatLng);
                             // íƒ€ì›ì„ ì›ìœ¼ë¡œ ê·¼ì‚¬í™”
                             const majorAxis = entity.majorAxis || { x: 1, y: 0 };
                             const majorPoint = { 
                                 x: entity.center.x + majorAxis.x, 
                                 y: entity.center.y + majorAxis.y 
                             };
                             const majorLatLng = transform(majorPoint);
                             if (majorLatLng) {
                                 radius = L.latLng(centerLatLng).distanceTo(L.latLng(majorPoint));
                                 type = 'ellipse';
                             }
                         }
                     }
                     break;
             }
             return { latlngs, type, radius };
         }

                 // STA. ê°’ ê³„ì‚° í•¨ìˆ˜ (ê¸°ì¤€ì  ë°ì´í„° ê¸°ë°˜)
        function calculateSTA(latlng, stationStart = 0) {
            // í´ë¦­í•œ ìœ„ì¹˜ë¥¼ EPSG:5186 ì¢Œí‘œë¡œ ë³€í™˜
            const [clickX, clickY] = proj4('EPSG:4326', 'EPSG:5186', [latlng.lng, latlng.lat]);
            
            let minDistance = Infinity;
            let closestSTA = 'ê³„ì‚° ë¶ˆê°€';
            let closestPoint = null;
            
            // ëª¨ë“  ê¸°ì¤€ì ê³¼ì˜ ê±°ë¦¬ ê³„ì‚°í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ì§€ì  ì°¾ê¸°
            referencePoints.forEach(point => {
                const distance = Math.sqrt(
                    Math.pow(clickX - point.x, 2) + Math.pow(clickY - point.y, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                }
            });
            
            if (closestPoint) {
                // ê¸°ì¤€ì ì—ì„œ í´ë¦­í•œ ì§€ì ê¹Œì§€ì˜ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚° (ë¯¸í„° ë‹¨ìœ„)
                const distanceFromReference = Math.sqrt(
                    Math.pow(clickX - closestPoint.x, 2) + Math.pow(clickY - closestPoint.y, 2)
                );
                
                // ë…¸ì„  ì§„í–‰ ë°©í–¥ì„ ê³ ë ¤í•œ STA ê°’ ê³„ì‚°
                // ê¸°ì¤€ì ì˜ STA ê°’ì— ê±°ë¦¬ ì°¨ì´ë¥¼ ë”í•˜ê±°ë‚˜ ë¹¼ê¸°
                let estimatedSTA = closestPoint.sta;
                
                // í´ë¦­í•œ ì§€ì ì´ ê¸°ì¤€ì ë³´ë‹¤ ë…¸ì„  ì§„í–‰ ë°©í–¥ì— ìˆëŠ”ì§€ íŒë‹¨
                // ê°„ë‹¨í•œ ë°©ë²•: Y ì¢Œí‘œê°€ ì‘ì„ìˆ˜ë¡ ë…¸ì„  ì§„í–‰ ë°©í–¥ (25km â†’ 27km)
                const isForward = clickY < closestPoint.y;
                
                if (isForward) {
                    // ë…¸ì„  ì§„í–‰ ë°©í–¥: STA ê°’ ì¦ê°€
                    estimatedSTA = closestPoint.sta + distanceFromReference;
                } else {
                    // ë…¸ì„  ë°˜ëŒ€ ë°©í–¥: STA ê°’ ê°ì†Œ
                    estimatedSTA = closestPoint.sta - distanceFromReference;
                }
                
                // STA. í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (km+m í˜•ì‹)
                const km = Math.floor(estimatedSTA / 1000);
                const m = Math.round(estimatedSTA % 1000);
                closestSTA = `STA. ${km}km${m.toString().padStart(3, '0')}`;
                
                // ë””ë²„ê¹…ìš© ì½˜ì†” ì¶œë ¥
                console.log(`ê¸°ì¤€ì : STA.${closestPoint.sta}m (${closestPoint.x}, ${closestPoint.y})`);
                console.log(`í´ë¦­ìœ„ì¹˜: (${clickX.toFixed(3)}, ${clickY.toFixed(3)})`);
                console.log(`ê±°ë¦¬: ${distanceFromReference.toFixed(2)}m`);
                console.log(`ë°©í–¥: ${isForward ? 'ì§„í–‰ë°©í–¥' : 'ë°˜ëŒ€ë°©í–¥'}`);
                console.log(`ê³„ì‚°ëœ STA: ${estimatedSTA.toFixed(2)}m`);
            }
            
            return closestSTA;
        }
        
        // ë ˆì´ì–´ íˆ¬ëª…ë„ ì„¤ì • (ê°œì„ ëœ ë²„ì „)
        function setLayerOpacity(layerName, opacity) {
            const layerGroup = layerGroups.get(layerName);
            if (layerGroup) {
                // ë ˆì´ì–´ ê·¸ë£¹ ë‚´ì˜ ëª¨ë“  ë ˆì´ì–´ì— íˆ¬ëª…ë„ ì ìš©
                layerGroup.eachLayer(function(layer) {
                    if (layer.setStyle) {
                        layer.setStyle({ opacity: opacity });
                    }
                });
            }
        }
    </script>
</body>
</html>